# 程序员的自我修养

### 链接，装载与库

## 第1章 温故知新

### 1.1 从Hello World说起

### 1.2 万变不离其宗

粗略介绍了计算机硬件体系。

### 1.3 站得高，望得远

> Any problem in computer science can be solved by another layer of indirection!

强调了计算机软件体系的分层思想。

### 1.4  操作系统做什么

#### 1.4.1 不要让CPU打盹

#### 1.4.2 设备驱动

> 在x86平台上，共有65536个硬件端口寄存器。

### 1.5 内存不够怎么办

#### 1.5.1 关于隔离

提及虚拟地址。

#### 1.5.2 分段（Segmentation）

#### 1.5.3 分页（Paging）

### 1.6 众人拾柴火焰高

#### 1.6.1 线程基础

> 在Linux内核中并不存在整整意义上的线程概念。

> `fork`和`exec`通常用于产生新任务，而如果要产生新线程，则可以使用`clone`。

#### 1.6.2 线程安全

栈和寄存器是线程私有的，这里着重理解寄存器是线程间各自独立这件事，见以下代码：

```
x = 0;
Thread1
lock();
x++;
unlock();

Thread2
lock();
x++;
unlock();
```

如果编译器为了提高x的访问速度，把x放到寄存器中，那么lock就有可能失效。这个时候可以使用`volatile`关键字来阻止过度优化。

`volatile`可以组织编译器调整顺序，但不能解决CPU动态调度换序问题。CPU提供一条`barrier`指令阻止换序，作用类似于一个拦水坝，阻止换序“穿透”这个大坝。

#### 1.6.3 多线程的内部情况

要理解用户级线程与内核线程的区别。

