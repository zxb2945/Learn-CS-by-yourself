# 程序员的自我修养

### 链接，装载与库

## 第1章 温故知新

### 1.1 从Hello World说起

### 1.2 万变不离其宗

粗略介绍了计算机硬件体系。

### 1.3 站得高，望得远

> Any problem in computer science can be solved by another layer of indirection!

强调了计算机软件体系的分层思想。

### 1.4  操作系统做什么

#### 1.4.1 不要让CPU打盹

#### 1.4.2 设备驱动

> 在x86平台上，共有65536个硬件端口寄存器。

### 1.5 内存不够怎么办

#### 1.5.1 关于隔离

提及虚拟地址。

#### 1.5.2 分段（Segmentation）

#### 1.5.3 分页（Paging）

### 1.6 众人拾柴火焰高

#### 1.6.1 线程基础

> 在Linux内核中并不存在整整意义上的线程概念。

> `fork`和`exec`通常用于产生新任务，而如果要产生新线程，则可以使用`clone`。

#### 1.6.2 线程安全

栈和寄存器是线程私有的，这里着重理解寄存器是线程间各自独立这件事，见以下代码：

```
x = 0;
Thread1
lock();
x++;
unlock();

Thread2
lock();
x++;
unlock();
```

如果编译器为了提高x的访问速度，把x放到寄存器中，那么lock就有可能失效。这个时候可以使用`volatile`关键字来阻止过度优化。

`volatile`可以组织编译器调整顺序，但不能解决CPU动态调度换序问题。CPU提供一条`barrier`指令阻止换序，作用类似于一个拦水坝，阻止换序“穿透”这个大坝。

#### 1.6.3 多线程的内部情况

要理解用户级线程与内核线程的区别。

## 第2章 编译和链接

### 2.1 被隐藏了的过程

Prepressing, Compilation, Assembly, Linking.

#### 2.1.1 预编译

#### 2.1.2 编译

#### 2.1.3 汇编

#### 2.1.4 链接

### 2.2 编译器做了什么

#### 2.2.1 词法分析

#### 2.2.2 语法分析

#### 2.2.3 语义分析

#### 2.2.4 中间语言生成

> 中间代码有很多种类型，最常见的有三地址码(Three-address Code).
>
> 中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

#### 2.2.5 目标代码生成与优化

### 2.3 链接器年龄比编译器长

### 2.4 模块拼装-静态链接

### 2.5 本章小结

## 第3章 目标文件里有什么

### 3.1 目标文件的格式

> Linux的ELF(Excutable Linkable Format)是PC平台流行的可执行文件格式，不光是可执行文件按照此格式存储，动态链接库，静态链接库，可重定位文件都按照可执行文件格式存储。

### 3.2 目标文件是什么样的

### 3.3 挖掘SimpleSection.o

#### 3.3.1 代码段

#### 3.3.2 数据段和只读数据段

> 调用`printf`的时候，用到了一个字符串常量“%d\n"，这是一种制度数据，所以它被放到了".rodata"段。

#### 3.3.3 BSS段

#### 3.3.4 其他段

### 3.4 ELF文件结构描述

#### 3.4.1 文件头

#### 3.4.2 段表

#### 3.4.3 重定位表

> 链接器在处理目标文件时，须要对目标文件里代码段和数据段中对绝对地址引用的位置进行重定位。

