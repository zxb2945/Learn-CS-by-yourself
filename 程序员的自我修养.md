# 程序员的自我修养

### 链接，装载与库

## 第1章 温故知新

### 1.1 从Hello World说起

### 1.2 万变不离其宗

粗略介绍了计算机硬件体系。

### 1.3 站得高，望得远

> Any problem in computer science can be solved by another layer of indirection!

强调了计算机软件体系的分层思想。

### 1.4  操作系统做什么

#### 1.4.1 不要让CPU打盹

#### 1.4.2 设备驱动

> 在x86平台上，共有65536个硬件端口寄存器。

### 1.5 内存不够怎么办

#### 1.5.1 关于隔离

提及虚拟地址。

#### 1.5.2 分段（Segmentation）

#### 1.5.3 分页（Paging）

### 1.6 众人拾柴火焰高

#### 1.6.1 线程基础

> 在Linux内核中并不存在整整意义上的线程概念。

> `fork`和`exec`通常用于产生新任务，而如果要产生新线程，则可以使用`clone`。

#### 1.6.2 线程安全

栈和寄存器是线程私有的，这里着重理解寄存器是线程间各自独立这件事，见以下代码：

```
x = 0;
Thread1
lock();
x++;
unlock();

Thread2
lock();
x++;
unlock();
```

如果编译器为了提高x的访问速度，把x放到寄存器中，那么lock就有可能失效。这个时候可以使用`volatile`关键字来阻止过度优化。

`volatile`可以组织编译器调整顺序，但不能解决CPU动态调度换序问题。CPU提供一条`barrier`指令阻止换序，作用类似于一个拦水坝，阻止换序“穿透”这个大坝。

#### 1.6.3 多线程的内部情况

要理解用户级线程与内核线程的区别。

## 第2章 编译和链接

### 2.1 被隐藏了的过程

Prepressing, Compilation, Assembly, Linking.

#### 2.1.1 预编译

#### 2.1.2 编译

#### 2.1.3 汇编

#### 2.1.4 链接

### 2.2 编译器做了什么

#### 2.2.1 词法分析

#### 2.2.2 语法分析

#### 2.2.3 语义分析

#### 2.2.4 中间语言生成

> 中间代码有很多种类型，最常见的有三地址码(Three-address Code).
>
> 中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

#### 2.2.5 目标代码生成与优化

### 2.3 链接器年龄比编译器长

### 2.4 模块拼装-静态链接

### 2.5 本章小结

## 第3章 目标文件里有什么

### 3.1 目标文件的格式

> Linux的ELF(Excutable Linkable Format)是PC平台流行的可执行文件格式，不光是可执行文件按照此格式存储，动态链接库，静态链接库，可重定位文件都按照可执行文件格式存储。

### 3.2 目标文件是什么样的

### 3.3 挖掘SimpleSection.o

#### 3.3.1 代码段

#### 3.3.2 数据段和只读数据段

> 调用`printf`的时候，用到了一个字符串常量“%d\n"，这是一种制度数据，所以它被放到了".rodata"段。

#### 3.3.3 BSS段

#### 3.3.4 其他段

### 3.4 ELF文件结构描述

#### 3.4.1 文件头

#### 3.4.2 段表

#### 3.4.3 重定位表

> 链接器在处理目标文件时，须要对目标文件里代码段和数据段中对绝对地址引用的位置进行重定位。

`...`



## 第8章 Linux共享库的组织

### 8.1 共享库

#### 8.1.1 共享库兼容性

#### 8.1.2 共享库版本命名

Linux的共享库命名规则如下：

```
libname.so.x.y.z
//x 主版本号 库的重大升级，不同主版本号之间不互相兼容
//y 次版本号 库的增量升级，向后兼容
//z 发布版本号 库的错误修正，不增加任何API，互相完全兼容
```

但最基本的C语言库Glibc没有遵守以上规则，采用`libc-x.y.z.so`的命名方式。

#### 8.1.3 SO-NAME

> 在Linux系统中，系统会为每个共享库在它所在的目录创建一个跟SO-NAME相同的并且指向它的软连接(Symbol Link)。比如系统中存在一个共享库`libfoo.so.2.6.1`, 那么库管理程序就会为它产生一个软连接`libfoo.so.2`指向它。

这个主要为了方便程序编译时自动兼容版本的更迭。主版本号更迭的话，SO-NAME独立创建。

### 8.2 符号版本

略

### 8.3 共享库系统路径

> Linux规定，一个系统中主要有三个存放共享库的位置：
>
> 1. `/lib`，这个位置主要存放系统最关键和基础的共享库，比如动态链接器，C语言运行库，数学库等，这些库主要是其它库以及系统启动时需要的库；
> 2. `usr/lib`，这个位置主要存放一些非系统运行时所需要的关键性的共享库，主要是一些开发时用到的共享库，一般不会被用户的程序或shell脚本直接用到；
> 3. `usr/local/lib`，这个位置主要来存放第三方应用的库，比如安装python语言的解释器时，相关库文件就会被存放到`usr/local/lib/python`，而可执行文件可能被放到`usr/local/bin`下。

### 8.4 共享库查找过程

> 动态链接器会依此遍历`/usr/lib`和`/lib`这两个目录。

### 8.5 环境变量

> 改变共享库查找路径最简单的方法是使用`LD_LIBARY_PATH`这个环境变量，它是一个由若干路径组成的环境变量，每个路径之间由冒号隔开。

### 8.6 共享库的创建和安装

```
gcc -shared -W1,-soname,my_soname -o libary_name source_files libary_files
```

最关键的是使用GCC的两个参数，即“-shared”和“-fPIC”。前者表示输出结果是共享库类型，后者表示使用地址无关代码技术来生产输出文件。



## 第11章 运行库

### 11.1 入口函数和程序初始化

#### 11.1.1 程序从main开始吗

> 1. 操作系统在创建进程后，把控制权交到了程序入口，这个入口往往是运行库的某个入口函数(Entry Point);
> 2. 入口函数对运行库和程序运行环境进行初始化，包括堆，I/O，线程，全局变量的构造，等等；
> 3. 入口函数在完成初始化后，调用main函数，正式开始执行程序主体部分。
> 4. main函数执行完毕以后，返回到入口函数，入口函数进行清理工作，包括全局变量析构，堆销毁，关闭I/O等，然后进行系统调用结束进程。

#### 11.1.2 入口函数如何实现

glibc是GNU发布的libc库（c运行库）。

> glibc的程序入口为`_start`, 它由汇编实现，并且与平台相关。在调用`_start`之前，装载器会把用户的参数和环境变量压入栈中。`_start`可以看成名为`__lib_start_main`的函数wrapping function. 
>
> `__lib_start_main`除了`mian`的函数指针之外，还要传入`init`,`fini`等三个函数指针，用于初始化和收尾工作。在最后终于调用`main`函数。
>
> `_exit`的作用仅仅是调用了`exit`这个系统调用。程序正常结束有两种情况，一种是`main`函数的正常返回，一种是程序中用`exit`退出。在`__lib_start_main`里我们可以看到，即使`main`返回了，`exit`也会被调用。`exit`是程序正常退出的必经之路。

