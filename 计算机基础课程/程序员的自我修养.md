# 程序员的自我修养

### 链接，装载与库

## 第1章 温故知新

### 1.1 从Hello World说起

### 1.2 万变不离其宗

粗略介绍了计算机硬件体系。

### 1.3 站得高，望得远

> Any problem in computer science can be solved by another layer of indirection!

强调了计算机软件体系的分层思想。

### 1.4  操作系统做什么

#### 1.4.1 不要让CPU打盹

#### 1.4.2 设备驱动

> 在x86平台上，共有65536个硬件端口寄存器。

### 1.5 内存不够怎么办

#### 1.5.1 关于隔离

提及虚拟地址。

#### 1.5.2 分段（Segmentation）

#### 1.5.3 分页（Paging）

### 1.6 众人拾柴火焰高

#### 1.6.1 线程基础

> 在Linux内核中并不存在整整意义上的线程概念。

> `fork`和`exec`通常用于产生新任务，而如果要产生新线程，则可以使用`clone`。

#### 1.6.2 线程安全

栈和寄存器是线程私有的，这里着重理解寄存器是线程间各自独立这件事，见以下代码：

```
x = 0;
Thread1
lock();
x++;
unlock();

Thread2
lock();
x++;
unlock();
```

如果编译器为了提高x的访问速度，把x放到寄存器中，那么lock就有可能失效。这个时候可以使用`volatile`关键字来阻止过度优化。

`volatile`可以组织编译器调整顺序，但不能解决CPU动态调度换序问题。CPU提供一条`barrier`指令阻止换序，作用类似于一个拦水坝，阻止换序“穿透”这个大坝。

#### 1.6.3 多线程的内部情况

要理解用户级线程与内核线程的区别。

## 第2章 编译和链接

### 2.1 被隐藏了的过程

Prepressing, Compilation, Assembly, Linking.

#### 2.1.1 预编译

#### 2.1.2 编译

#### 2.1.3 汇编

#### 2.1.4 链接

### 2.2 编译器做了什么

#### 2.2.1 词法分析

#### 2.2.2 语法分析

#### 2.2.3 语义分析

#### 2.2.4 中间语言生成

> 中间代码有很多种类型，最常见的有三地址码(Three-address Code).
>
> 中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

#### 2.2.5 目标代码生成与优化

### 2.3 链接器年龄比编译器长

### 2.4 模块拼装-静态链接

### 2.5 本章小结

## 第3章 目标文件里有什么

### 3.1 目标文件的格式

> Linux的ELF(Excutable Linkable Format)是PC平台流行的可执行文件格式，不光是可执行文件按照此格式存储，动态链接库，静态链接库，可重定位文件都按照可执行文件格式存储。

### 3.2 目标文件是什么样的

### 3.3 挖掘SimpleSection.o

#### 3.3.1 代码段

#### 3.3.2 数据段和只读数据段

> 调用`printf`的时候，用到了一个字符串常量“%d\n"，这是一种制度数据，所以它被放到了".rodata"段。

#### 3.3.3 BSS段

#### 3.3.4 其他段

### 3.4 ELF文件结构描述

#### 3.4.1 文件头

#### 3.4.2 段表

#### 3.4.3 重定位表

> 链接器在处理目标文件时，须要对目标文件里代码段和数据段中对绝对地址引用的位置进行重定位。

`...`



## 第8章 Linux共享库的组织

### 8.1 共享库

#### 8.1.1 共享库兼容性

#### 8.1.2 共享库版本命名

Linux的共享库命名规则如下：

```
libname.so.x.y.z
//x 主版本号 库的重大升级，不同主版本号之间不互相兼容
//y 次版本号 库的增量升级，向后兼容
//z 发布版本号 库的错误修正，不增加任何API，互相完全兼容
```

但最基本的C语言库Glibc没有遵守以上规则，采用`libc-x.y.z.so`的命名方式。

#### 8.1.3 SO-NAME

> 在Linux系统中，系统会为每个共享库在它所在的目录创建一个跟SO-NAME相同的并且指向它的软连接(Symbol Link)。比如系统中存在一个共享库`libfoo.so.2.6.1`, 那么库管理程序就会为它产生一个软连接`libfoo.so.2`指向它。

这个主要为了方便程序编译时自动兼容版本的更迭。主版本号更迭的话，SO-NAME独立创建。

### 8.2 符号版本

略

### 8.3 共享库系统路径

> Linux规定，一个系统中主要有三个存放共享库的位置：
>
> 1. `/lib`，这个位置主要存放系统最关键和基础的共享库，比如动态链接器，C语言运行库，数学库等，这些库主要是其它库以及系统启动时需要的库；
> 2. `usr/lib`，这个位置主要存放一些非系统运行时所需要的关键性的共享库，主要是一些开发时用到的共享库，一般不会被用户的程序或shell脚本直接用到；
> 3. `usr/local/lib`，这个位置主要来存放第三方应用的库，比如安装python语言的解释器时，相关库文件就会被存放到`usr/local/lib/python`，而可执行文件可能被放到`usr/local/bin`下。

### 8.4 共享库查找过程

> 动态链接器会依此遍历`/usr/lib`和`/lib`这两个目录。

### 8.5 环境变量

> 改变共享库查找路径最简单的方法是使用`LD_LIBARY_PATH`这个环境变量，它是一个由若干路径组成的环境变量，每个路径之间由冒号隔开。

### 8.6 共享库的创建和安装

```
gcc -shared -W1,-soname,my_soname -o libary_name source_files libary_files
```

最关键的是使用GCC的两个参数，即“-shared”和“-fPIC”。前者表示输出结果是共享库类型，后者表示使用地址无关代码技术来生产输出文件。



## 第11章 运行库

### 11.1 入口函数和程序初始化

#### 11.1.1 程序从main开始吗

> 1. 操作系统在创建进程后，把控制权交到了程序入口，这个入口往往是运行库的某个入口函数(Entry Point);
> 2. 入口函数对运行库和程序运行环境进行初始化，包括堆，I/O，线程，全局变量的构造，等等；
> 3. 入口函数在完成初始化后，调用main函数，正式开始执行程序主体部分。
> 4. main函数执行完毕以后，返回到入口函数，入口函数进行清理工作，包括全局变量析构，堆销毁，关闭I/O等，然后进行系统调用结束进程。

#### 11.1.2 入口函数如何实现

glibc是GNU发布的libc库（c运行库）。

> glibc的程序入口为`_start`, 它由汇编实现，并且与平台相关。在调用`_start`之前，装载器会把用户的参数和环境变量压入栈中。`_start`可以看成名为`__lib_start_main`的函数wrapping function. 
>
> `__lib_start_main`除了`mian`的函数指针之外，还要传入`init`,`fini`等三个函数指针，用于初始化和收尾工作。在最后终于调用`main`函数。
>
> `_exit`的作用仅仅是调用了`exit`这个系统调用。程序正常结束有两种情况，一种是`main`函数的正常返回，一种是程序中用`exit`退出。在`__lib_start_main`里我们可以看到，即使`main`返回了，`exit`也会被调用。`exit`是程序正常退出的必经之路。

#### 11.1.3 运行库与I/O

> I/O初始化函数需要在用户空间建立stdin, stdout, stderr及对应的FILE结构，使得程序进入main之后可以直接使用printf, scanf等函数。

> 入口函数最重要的两个部分，堆初始化和I/O初始化。入口函数隶属的是一个庞大的代码集合，这个代码集合叫做运行库。

### 11.2 C/C++运行库

#### 11.2.1 C语言运行库

> 任何一个C程序，它的背后都有一套庞大的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，及其所依赖的函数所构成的函数集合。当然，它还理应包括各种标准库函数的实现。
>
> 这样的一个代码集合称之为运行时库(Runtime Library)。而C语言的运行库，即被称为C运行库(CRT)。

> 一个C语言运行库大致包含了如下功能：
>
> 启动与退出：包括入口函数及入口函数所依赖的其它函数等。
>
> 标准函数：由C语言标准规定的C语言标准库所拥有的函数实现。
>
> I/O：I/O功能的封装和实现。
>
> 堆：堆的封装和实现。
>
> 语言实现：语言中一些特殊功能的实现。
>
> 调试：实现调试功能的代码。

#### 11.2.1 C语言标准库

> 在这些运行库的组成部分中，C语言标准库占据了主要地位。C语言标准库是C语言标准化的基础函数库，各平台通用。
>
> 美国国家标准协会(ANSI)在1983年成立了一个委员会，旨在对C语言进行标准化，此委员所建立的C语言标准称为ANSI C。在1999年，C99标准诞生，自此C标准库的面貌一直延续至今。
>
> ANSI C的标准库由24个C头文件组成。与许多其它语言（如JAVA）不同，C语言标准库非常轻量，它仅仅包含了数学函数，字符/字符串处理，I/O等基本方面，例如：
>
> 标准输入输出（包括文件操作）：stdio.h
>
> 字符串操作：string.h
>
> 数学函数：math.h
>
> 时间/日期：time.h
>
> 资源管理，格式转化：stdlib.h
>
> ...

#### 11.2.3 glibc与MSVC CRT

> 运行库是平台相关的，因为它与操作系统结合得非常紧密。C语言的运行库从某种程度上来讲是C语言的程序和不同操作平台之间的抽象层，它将不同的操作系统API抽象成相同的库函数。
>
> 但很多时候运行库所提供的函数毕竟有限，比如用户的权限控制，操作系统线程创建等都不是属于标准的C语言运行库。于是我们不得不通过其他办法，诸如绕过C语言运行库直接调用操作系统API或使用其它的库。
>
> Linux和Windows平台下的两个主要C语言运行库分别为glibc(GNU C Library)和MSVCRT(Mocrosoft Visual C Run-time)。
>
> glibc和MSVCRT都包含了线程操作的库函数，比如glibc有一个可选的pthread库，所以glibc事实上是标准C语言运行库的超集，对C标准库进行了扩展。

> 在Linux各个发行版中，glibc往往被称为libc6.
>
> glibc的发行版本主要有两部分组成，一部分是头文件，比如stdio.h, stdlib.h等，它们位于/usr/include;
>
> 另一部分是库的二进制文件。动态标准库位于/usr/libc.so.6;
>
> 静态标准库位于/usr/lib/libc.a;
>
> glibc除了C标准库之外，运行库的其他部分位于/usr/lib/crt1.o, /usr/lib/crti.o, /usr/lib/crtn.o.

> glibc只是一个C语言运行库，它对C++的实现并不了解。C++这样的语言的实现是跟编译器密切相关的，所以GCC是C++的真正实现者，它对C++的全局构造和析构了如指掌。于是GCC提供了相关文件来配合glibc实现C++的全局构造和析构，它们主要位于/usr/lib/gcc目录下。

### 11.3 运行库与多线程

#### 11.3.1 CRT的多线程困扰

> 对于C/C++标准库来说，线程相关部分是不属于标准库的内容的，它跟网络，图形图像等一样，属于标准库之外的系统相关库。

C语言运行库适应多线程环境所面临的困难：

> 1. errno: 多线程并发时候，错误信息被覆盖；
> 2. 使用内部局部静态变量的`strtok`等函数；
> 3. malloc/free不提前枷锁的情况下线程不安全；
> 4. printf/fprintf及其它IO函数，因为它们共享了同一个控制台或文件输出。

#### 11.3.2 CRT的改进

以改进适应多线程版本的glibc为例：

1. 使用TLS(Thread local Storage)存储errno；
2. 使用新的线程安全版本函数，如`strtok_r`；
3. malloc和printf等在函数内部直接自动地加锁（参数列表不变的前提下）；

#### 11.3.3 线程局部储存实现

TLS用法很简单，只需定义前加关键字，对于GCC，就是`_thread`.

### 11.4 C++全局构造与析构

#### 11.4.1 glibc全局构造与析构

> C++的全局对象构造是与语言密切相关的，相应负责的函数来自于GCC编译器也非常容易理解。

### 11.5 fread实现

CRT与任何系统级别的软件一样，真正复杂的是软件与外部通信的部分，即IO部分。

#### 11.5.1 缓冲

#### 11.5.5 文本换行

1. Linux/Unix: 回车用`\n`表示；
2. Windows：回车用`\r\n`表示；

在C语言中，回车始终用`\n`来表示，以文本模式读取文件的时候，不同操作主要是windows需要将`\r\n`转换为`\n`来表示。



## 第13章 运行库的实现

### 13.1 C语言运行库

#### 13.1.1 入口函数

#### 13.1.2 堆的实现

实现一个以空闲链表算法为基础的堆空间分配算法。

#### 13.1.3 IO与文件操作

> 在x86下，系统调用由0x80中断完成，各个通用寄存器用于传递参数，EAX寄存器用于表示系统调用的接口号，比如EAX=3表示读取文件或IO(read)，每个系统调用都对应于内核源代码中的一个函数，比如`sys_read`函数。
>
> Linux内核版本2.6.19总共提供了319个系统调用，都可以在程序里直接使用，他们的C语言形式被定义在"/usr/include/unistd.h"中，比如我们完全可以绕过glibc的fread而直接使用read()来实现文件的读取，只是位于glibc中的缓冲，按行读取文本文件等这些机制就没有了。
>
> 但是，系统调用如read()的弊端在于其不能跨操作系统（windows中所用的是ReadFile这个API），而C语言运行库中的fread就不存在这个问题。

（注意运行库，操作系统跟内核的细微区别，就是fread()，read()和sys_read()的区别）

必须使用内嵌汇编实现open,read,write,close和seek这几个系统调用，例如`int 0x80`.

（上面这个方针，就是摈弃了Linux自身提供的系统调用，在运行库中自己写了。）

#### 13.1.4 字符串相关操作

这部分无须设计任何与内核的交互，是纯粹的用户态的计算，所以他们的实现相对比较简单。

#### 13.1.5 格式化字符串

实现CRT中如雷贯耳的函数printf，一个典型的变长参数函数。

实现字符串格式化，复杂性来自于对格式化字符串的分析，可以使用的算法：1.定义翻译模式/普通模式；2.循环整个格式字符串。遇到`%`，进入翻译模式...

### 13.3 C++运行库的实现

C++作为兼容C语言的扩展语言，最基本的实现并不复杂。

C++标准模板库STL包含了诸如流，容器，算法，字符串等，规模较为庞大，不得不简化。

#### 13.3.1 new与delete

> new操作的功能是从堆上分配一块对象大小的空间，然后运行对象的初始化函数将这个空间地址返回。
>
> new可以像“+”，“-”一样被认为是操作符，C++中这些操作符都有相对应的操作符函数。

既然new的实现是相应的操作符函数，只需做malloc的包裹函数就行。

#### 13.3.2 C++全局构造与析构

> C++全局构造与析构的实现是依赖于编译器，链接器和运行库三者共同的支持和协作的。

#### 13.3.5 stream和string

> 流和字符串是C++STL的最基本的两部分

