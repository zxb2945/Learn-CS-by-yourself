# 编程练习

## demo task

2022.11.10

This is a demo task.

Write a function:

> ```
> int solution(int A[], int N);
> ```

that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an ***\*efficient\**** algorithm for the following assumptions:

> - N is an integer within the range [1..100,000];
> - each element of array A is an integer within the range [−1,000,000..1,000,000].

**Solution：**

```
int solution(int A[], int N) {
    // write your code in C99 (gcc 6.2.0)

   int i,j,t;
   int ans=1;

    for(i=0;i<N-1;i++)//n个数的数列总共扫描n-1次
    {
        for(j=0;j<N-i-1;j++)//每一趟扫描到a[n-i-2]与a[n-i-1]比较为止结束
        {
            if(A[j]>A[j+1])//后一位数比前一位数小的话，就交换两个数的位置（升序）
            {
               t=A[j+1];
               A[j+1]=A[j];
               A[j]=t;
            }
        }
    }

    for(i=0;i<N;i++)
    {
        if(A[i]<1 || (i>0 && A[i]==A[i-1])){
            continue;
        }
        
        if(A[i]>ans){
            return ans;
        }else{
            ans++;
           // printf("A[i]: %d\n", A[i]);
           // printf("Answer: %d\n", ans);
        }
    }

    return ans;
}

```



```C++
vector<int> merge(vector<int> a, vector<int> b) {
	vector<int> res;
	size_t ai = 0, bi = 0;
	while (ai < a.size() && bi < b.size()) {
		if (a[ai] <= b[bi])
			res.push_back(a[ai++]);
		else
			res.push_back(b[bi++]);
	}
	if (ai == a.size())
		res.insert(res.end(), b.begin() + bi, b.end());
	else if (bi == b.size())
		res.insert(res.end(), a.begin() + ai, a.end());
	return res;
}

vector<int> mergeSort(vector<int>& arr) {
	if (arr.size() < 2) return arr;
	const size_t mid = arr.size() / 2;
	vector<int> left(arr.begin(), arr.begin() + mid);
	vector<int> right(arr.begin() + mid, arr.end());
	return merge(mergeSort(left), mergeSort(right));
}

int solution(vector<int> &A) {
    // write your code in C++14 (g++ 6.2.0)

	A = mergeSort(A);
	
	for (const int& a : A)
		cout << a << ' ';
	cout << endl;

    int i,j,ans=1;
    for(i=0;i<A.size();i++)
    {
        if(A[i]<1 || (i>0 && A[i]==A[i-1])){
            continue;
        }
        
        if(A[i]>ans){
            return ans;
        }else{
            ans++;
           // printf("A[i]: %d\n", A[i]);
           // printf("Answer: %d\n", ans);
        }
    }
    return ans;
}


```



## 1.Palindrome Number

2022.11.15

> Given an integer `x`, return `true` *if* `x` *is a* ***palindrome****, and* `false` *otherwise*.

```c++
#include <sstream> //stringstream
#include <string> //string
#include <iostream> 
#include <algorithm> //reverse


class Solution {
public:
    bool isPalindrome(int x) {
        stringstream ss;
        string str, str2;

        if(x < 0){
            return false;
        }

        ss << x;
        ss >> str; // convert intger to string through stringstream
        str2 = str;
        cout << str2 << endl; //endl=>end line
        reverse(str.begin(), str.end());

        if(str == str2){
            return true;
        }else{
            return false;
        }
    }
};
```

