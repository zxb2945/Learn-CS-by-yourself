# Python-100-Days（Github）

## 2021.2.1

### day1 初识Python

多行注释 - 三个引号开头，三个引号结尾

PyCharm - Python开发神器

> 在使用pycharm时，经常会需要多行代码同时缩进、左移，pycharm提供了快捷方式
>
> 1、pycharm使多行代码同时缩进
>
>   鼠标选中多行代码后，按下Tab键，一次缩进四个字符
>
> 2、pycharm使多行代码同时左移
>
>  鼠标选中多行代码后，同时按住shift+Tab键，一次左移四个字符

使用turtle在屏幕上绘制图形

pip 是 Python 的包管理器。这意味着它是一个工具，允许你安装和管理不属于标准库的其他库和依赖。

`pip install` 命令只会安装最新发布的软件包版本，但是有时候，你可能希望根据代码运行情况安装特定的版本:软件包的版本会根据 `requirements.txt` 所列出的进行匹配



#### if \_\_name__ == '\_\_main__':

运行原理:**每个python模块**（python文件，也就是此处的 test.py 和 import_test.py）都包含**内置的变量 __name__**，当该模块被**直接执行**的时候，**__name__ 等于文件名（包含后缀 .py ）**；如果该模块 **import** 到其他模块中，**则该模块的 __name__ 等于模块名称（不包含后缀.py）。**而 **“__main__” 始终指当前执行模块的名称（包含后缀.py）**。进而当模块被**直接执   

(就自己做的实验来看，main就是一个字符串，无关乎模块名，只是name直接执行时等于main，不直接执行时估计是别的值对吧？所以对上面的解释存疑)

作用：一个python文件通常有两种使用方法，第一是作为脚本直接执行，第二是 import 到其他的 python 脚本中被调用（模块重用）执行。因此 if __name__ == 'main': 的作用就是控制这两种情况执行代码的过程，在 if __name__ == 'main': 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而 import 到其他脚本中是不会被执行的。

区别：这行代码并非等同于C/C++、Java或C#等语言中的main()函数，在Python程序中这行代码也并非一定要存在于执行代码中，其主要作用是为了调试模块中代码的正确性。

## 2021.2.3

### day2 语言元素

整型，浮点型，字符串型，布尔型，复数型 => 这比C简洁多了！！！就必需的几种对吧！！！

玩转Pycharm，怎么安装的。

`ord()`字符转ascll码

input()，print()  =>输入输出，也比C简洁！

```
a = float(input('a = '))
#在输入值前加说明信息，直接单引号字符串
>>> print( '%f' % a)
5.000000
>>> print( '%d' % a)
5
>>> print( '%d' , a)
%d 5
>>> print(a)
5
#注意%的作用。。。
```

逻辑运算符有三个，分别是`and`、`or`和`not`。=》与布尔型一样，more readible

### day3 分支结构

Python中没有用花括号来构造代码块而是**使用了缩进的方式来表示代码的层次结构**,**缩进**可以使用任意数量的空格，但**通常使用4个空格**，建议大家**不要使用制表键**

在之前我们提到的Python之禅中有这么一句话“Flat is better than nested.”，之所以提倡代码“扁平化”是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，所以能使用扁平化的结构时就不要使用嵌套。=>if else尽量不嵌套，使之平行

elif  =》 跟shell一样，跟c不同

### day4 循环结构

通过下面的操作将y的值赋给x, 将x的值赋给y

    x, y = y, x

=》牛逼啊，python都不用引用第三者就能交换

记得for，while循环判断后面要加冒号，基本IDE会提示你的嘛，这种问题

pycharm使多行代码同时缩进： 鼠标选中多行代码后，按下Tab键，一次缩进四个字符

for in基本计数的话就跟range配对的嘛！ =》与c就不同

### day5 构造程序逻辑

Python的核心语言元素（变量、类型、运算符、表达式、分支结构、循环结构等）

### day6 函数和模块的使用

但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载:     两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值,这跟其他很多语言中函数重载的效果是一致的。

=>也就是说，python是通过参数设默认值来达到函数重载的效果？但是参数不能超过默认值参数个数，理所当然，不然你多出来的参数进去有什么用嘛。。。

```
def test(a=0,b=0):
    c=a+b
    return c

test(1,2,3)

C:\Python\venv\Scripts\python.exe C:/Python/函数的参数可以有默认值.py
Traceback (most recent call last):
  File "C:\Python\函数的参数可以有默认值.py", line 9, in <module>
    test(1,2,3)
TypeError: test() takes from 0 to 2 positional arguments but 3 were given

```

同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。

那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过`import`关键字导入指定的模块就可以区分到底要使用的是哪个模块中的`foo`函数

=》所以只要保证同一个文件中没有重复函数名就可以了

需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是&quot;\_\_main\_\_&quot;。

=》就是下面这个的由来！！！所以浙大的这个课在讲些什么。。。

```
if __name__ == '__main__':
```

变量的作用域：Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些标识符，我们之前用过的`input`、`print`、`int`等都属于内置作用域。

=》也就是说，外层局部变量直接可以让里面的函数用，这就省去了传什么地址啥的。。。！！！！NONONO，理解大错误！！！必须加global才能传进去，不然里面只是重新定义一个局部变量

```
def out_func():
    a=1
    def inner_func():
        a=3
        print(a)

    print(a)
    inner_func()

if __name__ == '__main__':
    out_func()
    #inner_func() => NameError: name 'inner_func' is not defined
```

上面打出1，3.    =>   说明函数对自己内部定义的函数里面没法察觉变化（除非调用），但里面的函数可以感知之前外部函数怎么修改变量的。 =>  NONONO,理解错误了！！上面a=3是不同于a=1的变量，重新定义了一个名字为`a`的局部变量，它跟全局作用域的`a`并不是同一个变量，因为局部作用域中有了自己的变量`a`，因此inner_func函数不再搜索全局作用域中的`a`。如果我们希望在`foo`函数中修改全局作用域中的`a`，代码如下所示。

```
def foo():
    global a
    a = 200
    print(a)  # 200


if __name__ == '__main__':
    a = 100
    foo()
    print(a)  # 200
```

加个 global，就能传进去了。我们可以使用`global`关键字来指示`foo`函数中的变量`a`来自于全局作用域，如果全局作用域中没有`a`，那么下面一行的代码就会定义变量`a`并将其置于全局作用域。

同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用`nonlocal`关键字来指示变量来自于嵌套作用域，请大家自行试验。   =》下面摘自CSDN，比较清楚global和nonlocal的用法

```
a = 20    #第一个a
b = 10   #第一个b
def foo():
	a = 19    #第二个a
	b = 9     #第二个b
	def inner():
		global a
		a = 18    #可以修改第一个a,但是不能修改第二个a
		nonlocal b
		b = 8   #可以修改第二个b，但是不能修改第一个b
```

在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被[垃圾回收](https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措

## 2021.2.5

### day7 字符串和常用数据结构

在`\`后面还可以跟一个八进制或者十六进制数来表示字符，例如`\141`和`\x61`都代表小写字母`a`，前者是八进制的表示法，后者是十六进制的表示法。也可以在`\`后面跟Unicode字符编码来表示字符，例如`\u9a86\u660a`代表的是中文“骆昊”。=》C中就没有这种在字符串中用Unicode码转化方式对吧。。。ASCII码也没有

如果不希望字符串中的`\`表示转义，我们可以通过在字符串的最前面加上字母`r`来加以说明 =》像这样细节的东西呢，其实到运用时再去查细节就行，初学时候就不用在意

```
"""
Python为字符串类型提供了非常丰富的运算符，我们可以使用`+`运算符来实现字符串的拼接，可以使用`*`运算符
来重复一个字符串的内容，可以使用`in`和`not in`来判断一个字符串是否包含另外一个字符串（成员运算），我
们也可以用`[]`和`[:]`运算符从字符串取出某个字符或某些字符（切片运算）
"""

s1 = 'abc'
s2 = 'zxc'
print(s1+s2)
print(s1*2)
a = 'a' not in s1
print(a)
print(s1[1])
print(s1[:2])

abczxc
abcabc
False
b
ab
```

=》python中的字符串就像C++中的容器，运算符全部重载，并且还有许多方法可调用，加个点号就行（当然方法后面的括号别忘了）

字符串类型是一种结构化的、非标量类型，所以才会有一系列的属性和方法。

=》在C中 字符串和字符型数组本质上是一样的

 enumerate多用于在for循环中得到计数，比如对一个列表，既要遍历索引又要遍历元素时=》挺常见

列表怎么说呢？它的元素可以是字符串，这就跟C中数组很不一样了，所以python中的数据结构就要完全摈弃C中的概念，完全是另起了一套，列表与字符串的关系就像C中结构体与数组的关系。。。列表也有各种增删改各种配套函数，也能切片，字符串也能重载，python中数据结构就很open。

```
f = [x + y for x in 'ABCDE' for y in '1234567']
print(f)
# 用列表的生成表达式语法创建列表容器
```

\*  代表乘法

** 代表乘方

除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过`yield`关键字将一个普通函数改造成生成器函数：    yield是用于生成器。什么是生成器，你可以通俗的认为，在一个函数中，使用了yield来代替return的位置的函数，就是生成器。它不同于函数的使用方法是：函数使用return来进行返回值，每调用一次，返回一个新加工好的数据返回给你；yield不同，它会在调用生成器的时候，把数据生成object，然后当你需要用的时候，要用next()方法来取，同时不可逆。你可以通俗的叫它"轮转容器"，可用现实的一种实物来理解：水车，先yield来装入数据、产出generator object、使用next()来释放；好比水车转动后，车轮上的水槽装入水，随着轮子转动，被转到下面的水槽就能将水送入水道中流入田里。

```
def fib(n):
    a, b = 0, 1
    #这个下引号就是index用不着吧，所以不写了，python任性
    for _ in range(n):
        a, b = b, a + b
        yield a


def main():
    for val in fib(20):
        print(val)


if __name__ == '__main__':
    main()
```

#### tuple和list的区别

Python中的元组(tuple)与列表(list)类似也是一种容器数据类型，可以用一个变量（对象）来存储多个数据，不同之处在于元组的元素不能修改  =》元组跟列表的区别：形式上在于后者用[],他用(),用法上就是元组元素没法被修改

深层次的区别：列表和元组最重要的区别就是，列表是动态的、可变的，而元组是静态的、不可变的。这样的差异势必会影响两者存储方式，区别主要在于 `list()` 是一个 function call，Python 的 function call 会创建 stack，并且进行一系列参数检查的操作，开销较大，反观 `[]` 是一个内置的 C 函数，可以直接被调用，因此效率高。

列表和元组都是有序的（可通过下标检索），可以存储任意数据类型的集合，主要有以下区别：

- 列表是动态的，长度可变，可以随意地增删改元素。列表的存储空间略大于元组，性能略逊于元组。
- 元组是静态的，长度大小固定，不可以对元组元素进行增删改操作。元组对于列表更加轻量级，性能稍优。



Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。=》然后使用{}，这样tuple，listhe集合各自使用不同的括号了。

字典是另一种可变容器模型，Python中的字典跟我们生活中使用的字典是一样一样的，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。



```
#if has_dot=True index = pos else index = pos + 1,python的语法真是自由
        index = pos if has_dot else pos + 1
```



=》总结，记住python的五种数据结构：字符串，list，tuple，集合以及dictionary。



```
def max2(x):
    m1, m2 = (x[0], x[1]) if x[0] > x[1] else (x[1], x[0])
    for index in range(2, len(x)):
        if x[index] > m1:
            m2 = m1
            m1 = x[index]
        elif x[index] > m2:
            m2 = x[index]
#你说=后都可以跟多个，return多个也是理所当然的，其实这一点让python写起来就很自由=》而且非常常见
    return m1, m2
```

## 2021.2.7

### day8 面向对象编程基础

#### Python中定义类时，class, class()和class(object)的区别

为什么要继承object类？主要目的是便于统一操作。在python 3.X中已经默认继承object类.所以，继承object类是为了***\*让自己定义的类拥有更多的属性\****，以便使用。当然如果用不到，不继承object类也可以。python2中继承object类是为了和python3保持一致，python3中自动继承了object类。

=》python3中三者是等价的，python2中前两者不继承object。所以class(object)是类继承的形式。



​    \_\_init__是一个特殊方法用于在创建对象时进行初始化操作



#### 深入理解python之self

首先明确的是self只有在类的方法中才会有，独立的函数或方法是不必带有self的。self在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。self名称不是必须的，在python中self不是关键词，你可以定义成a或b或其它名字都可以,但是约定成俗，不要搞另类，大家会不明白的。self指的是类实例对象本身(注意：不是类本身)。



在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头.但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们.在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻

=>全靠程序员自觉遵守语法规范



### day9 面向对象进阶

之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便

```
class DataSet(object):
  @property
  def method_with_property(self): ##含有@property
      return 15
  def method_without_property(self): ##不含@property
      return 15

l = DataSet()
print(l.method_with_property) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。  结果：15
print(l.method_without_property())  #没有加@property , 必须使用正常的调用方法的形式，即在后面加()   结果15
```

=》@property形式上就是调用时不加（）？？原因=》  如果使用property进行修饰后，又在调用的时候，方法后面添加了()， 那么就会显示错误信息：TypeError: ‘int’ object is not callable，也就是说添加@property 后，这个方法就变成了一个属性，如果后面加入了()，那么就是当作函数来调用，而它却不是callable（可调用）的。

=》使用property进行修饰后，这个方法就不是方法，而是属性，性质就不一样了

```
class DataSet(object):
    def __init__(self):
        self._images = 1
        self._labels = 2 #定义属性的名称
    @property
    def images(self): #方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。
        return self._images 
    @property
    def labels(self):
        return self._labels
l = DataSet()
#用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。
print(l.images) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。
```

=》这里不是访问器与直接用方法形式两者比较，而是访问器与直接操作self._images比较。。。前者没有意义



至于修改器如下：

```
class Person(object):

    def __init__(self, name, age):
        self._name = name
        self._age = age

    # 修改器 - setter方法
    @age.setter
    def age(self, age):
        self._age = age

def main():
    person = Person('王大锤', 12)
    person.age = 22

if __name__ == '__main__':
    main()
```

=》可见age就像一个变量，而不是方法，从而来说python大概是不推荐直接访问变量的，推荐修改器来告诉别人这个变量可以被修改。



Python是一门[动态语言](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80)。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义\_\_slots\_\_变量来进行限定。需要注意的是\_\_slots\_\_的限定只对当前类的对象生效，对子类并不起任何作用。



之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法@staticmethod来解决这类问题  =》但这个感觉更多是逻辑上的提示，不加@staticmethod语法上也不报错



和静态方法比较类似，Python还可以在类中定义类方法@classmethod，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象 =》@classmethod在语法层面上跟它用到的cls参数就有关联了，如果没有的话，cls这边就要报错。

> 一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。但是使用@staticmethod或@classmethod，就可以不需要实例化。



```
class Student(Person):
    """学生"""

    def __init__(self, name, age, grade):
        super().__init__(name, age)
        self._grade = grade
```

=》继承中，似乎用super()表示父类



Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过`abc`模块的`ABCMeta`元类和`abstractmethod`包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。ABC是Abstract Base Class的缩写。  =》 随便了解一下，要用了再深究



## 2021.2.9

### day10 图形用户界面和游戏开发

**GUI**とは、**Graphical User Interface**

Python默认的GUI开发模块是tkinter =》就可以利用这个库来做视窗什么的。至于tkinter里面是什么逻辑就不重要，会用轮子就好。这也是代码开发的一个阶段对吧。



Pygame是一个开源的Python模块，专门用于多媒体应用（如电子游戏）的开发，其中包含对图像、声音、视频、事件、碰撞等的支持。Pygame建立在[SDL](https://zh.wikipedia.org/wiki/SDL)的基础上，SDL是一套跨平台的多媒体开发库，用C语言实现，被广泛的应用于游戏、模拟器、播放器等的开发。而Pygame让游戏开发者不再被底层语言束缚，可以更多的关注游戏的功能和逻辑。   =》好熟悉啊！果然这么有名，搞清楚了我估计就可以弄个游戏出来了。



初学者可能没见过 for 循环中的下划线，在 Python 中是占位符的意思，因为单纯的循环两次而已

```
for _ in range(2):
```



```
    # 开启一个事件循环处理发生的事件
    while running:
        # 从消息队列中获取事件并对事件进行处理
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
```

其实对上述代码块，我就是有如下疑惑：

1.event是怎样的一个数据结构呢？可以去模拟包括屏幕X按钮？

​    pygame.event.get()取走外部输入信息队列的时候是有个时间间隔的，这个间隔和程序本身运行的速度有关系，这里可以通过修改pygame.time.delay()里的值发现。之所以在for in pygame.event.get()循环里加入pygame.time.delay()这一句是因为程序跑的要比你手指输入快得多，现在有了pygame.time.delay()这个神器咱终于可以比程序跑得更快了，只要你以一定的速度输入下去，外部输入信息队列会因为pygame.event.get()不能及时取走而装的很多，当pygame.event.get()终于处理完曾经取走的信息，等待它的又是外部输入信息队列里好大一坨的外部输入信息··· ···

2.pygame.event.get()这样的形式是怎样的层次，可以用逗号来表示引用？

  =》**pygame.event**用于处理事件与事件队列的 Pygame 模块。

  =》import pygame.event

  =》pygame是一个文件夹，event是一个py文件，get()是一个函数



.py：这通常是您编写的输入源代码。

.pyi : MyPy存根,存根文件（PEP 484）



=》要不要自己手写一个坦克大战？？？？？



### day11 文件和异常

在Python中，我们可以将那些在运行时可能会出现状况的代码放在`try`代码块中，在`try`代码块的后面可以跟上一个或多个`except`来捕获可能出现的异常状况。=>跟C++一样

```
def main():
    f = None
    try:
        f = open('致橡树.txt', 'r', encoding='utf-8')
        print(f.read())
    except FileNotFoundError:
        print('无法打开指定的文件!')
    except LookupError:
        print('指定了未知的编码!')
    except UnicodeDecodeError:
        print('读取文件时解码错误!')
    finally:
        if f:
            f.close()


if __name__ == '__main__':
    main()
```

`finally`块的代码不论程序正常还是异常都会执行到（甚至是调用了`sys`模块的`exit`函数退出Python环境，`finally`块都会被执行，因为`exit`函数实质上是引发了`SystemExit`异常）



如果不愿意在`finally`代码块中关闭文件对象释放资源，也可以使用上下文语法，通过`with`关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。

```
def main():
    try:
        with open('致橡树.txt', 'r', encoding='utf-8') as f:
            print(f.read())
    except FileNotFoundError:
        print('无法打开指定的文件!')
    except LookupError:
        print('指定了未知的编码!')
    except UnicodeDecodeError:
        print('读取文件时解码错误!')


if __name__ == '__main__':
    main()
```



=>读文件嘛，C中怎么读我也没好好看过，大概吧，看到了就查呗

=》复制图片文件的功能：因为图片也是二进制文件嘛，也可以通过文件读出写进来完成复制



如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准 =》JSON原来这么牛逼。

=》果然如此啊，当时看到字典这种数据结构，跟JSON就一摸一样！=》JSON跟Python中的字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对应关系的

json模块主要有四个比较重要的函数，分别是：

- `dump` - 将Python对象按照JSON格式序列化到文件中

- `dumps` - 将Python对象处理成JSON格式的字符串

- `load` - 将文件中的JSON数据反序列化成对象

- `loads` - 将字符串的内容反序列化成Python对象

  =》这个吧，像这次开发都不用自己写。直接有json模块



## 2021.2.11

### day12 使用正则表达式

博客地址：https://deerchao.cn/tutorials/regex/regex.htm

> 和通配符（wildcard）类似，正则表达式(regular expression)也是用来进行文本匹配的工具

通配符跟正则表达式是不同的两个概念

> 今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。

re模块究竟是怎样的原理呢，这根本就不重要，黑盒思想嘛。你看着例子，会套用就行了。如果凡是寻根问底，那就只会苔藓不见天空。

正则表达式自身也是一样，直到是怎么回事，然后想用时就专门去查。否则即便现在花了半天研究，到头来不用基本全忘。

### day13 进程和线程

> Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。

C中多进程多线程编程有基础的话，python无非是接口函数不同，还是非常好理解的。同样有IPC通信机制，同样有锁机制。

> 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。



## 2021.2.14

### day14 网络编程入门

HTTP，JSON，XML这些我这三年天天打交道...原来是基础中的基础啊...

就这python requests库来看，可以以json形式从相应URL上pull数据下来，理论上应该是可以作为浏览器技术吧？



> 套接字就是一套用[C语言](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80)写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。

> 一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”）

基于传输层协议的套接字编程可以用来做简易的服务器和客户端。

原理性的东西广泛涉猎...

### day15 图像和办公文档处理

计算机图像相关知识：三原色和像素

简略提了下用于操作图像的pillow库，操作excel的openpyxl模块，操作word的docx的模块。

## 2021.2.25

### day16-20 Python语言进阶

```
prices = {
    'AAPL': 191.88,
    'GOOG': 1186.96,
    'IBM': 149.24,
    'ORCL': 48.44,
    'ACN': 166.89,
    'FB': 208.09,
    'SYMC': 21.29
}
# 用股票价格大于100元的股票构造一个新的字典
prices2 = {key: value for key, value in prices.items() if value > 100}
print(prices2)
```

生成式（推导式）应该是不占内存的，随用随查；

prices.items() 字典整体项用点item()来返回迭代器。

#### enumerate()的作用

```
names = ['关羽', '张飞', '赵云', '马超', '黄忠']
courses = ['语文', '数学', '英语']
# 录入五个学生三门课程的成绩
# 错误 - 参考http://pythontutor.com/visualize.html#mode=edit
# scores = [[None] * len(courses)] * len(names)
scores = [[None] * len(courses) for _ in range(len(names))]
for row, name in enumerate(names):
    for col, course in enumerate(courses):
        scores[row][col] = float(input(f'请输入{name}的{course}成绩: '))
        print(scores)
```

python的语言表现力很强，“scores = [[None] * len(courses) for _ in range(len(names))]”就生成一个矩阵，然后两个for循环赋值，enumerate可以同时返回index和value值。

看过SICP，骆昊这个就一般了，泛泛而谈的感觉。

#### lambda

```
g = lambda x: x+1  # 求 x+1 的和
```

跟C中 #define g(x) x+1 效果一样，冒号前为形参，冒号后为表达式



介绍了一些python的常用工具模块，这个意义不大，只能是碰到就查这种节奏。

然后讲了些算法...

> 将函数视为“一等公民”

这点在SICP中讲得非常透彻。

接下泛泛讲了面对对象比较深层的几个点，我薄弱处...

> 接口隔离原则（**I**SP）- 接口要小而专不要大而全（Python中没有接口的概念）

Python中没有接口的概念怎么去理解呢？CSDN查阅：

> 用Fluent Python里的话来讲, 要判断一个动物是不是鸭子, Java看的是它的血统: 是否实现了鸭子接口, 是一个鸭子实例； Python则是看它的行为: 是否像鸭子一样走路, 一样叫发声.

> 在python中接口由抽象类和抽象方法去实现，接口是不能被实例化的，只能被别的类继承去实现相应的功能。

```
from abc import ABCMeta,abstractmethod
 
class interface(object):
    __metaclass__ = ABCMeta #指定这是一个抽象类
    @abstractmethod  #抽象方法
    def Lee(self):
        pass
 
    def Marlon(self):
        pass
 
 
class RelalizeInterfaceLee(interface):#必须实现interface中的所有函数，否则会编译错误
    def __init__(self):    
        print '这是接口interface的实现'
    def Lee(self):
        print '实现Lee功能'        
    def Marlon(self):
        pass  
————————————————
版权声明：本文为CSDN博主「@溪竹」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_42181824/article/details/81874725
```

也就是说python中接口使用抽象楼来实现的，还不是像JAVA中那样需要implement。

迭代器和生成器加上协程在SICP中讲得比较详细

最后讲了并发编程（多进程多线程）

## 2021.2.28

### day21-30 Web前端概述

chrome Ctrl+U 查看网页html，还可以右上角三点点击开发者工具

> - XML和HTML为不同的目的而设计：XML被设计为传输和存储数据，其焦点是数据的内容；HTML被设计用来显示数据，其焦点是数据的外观。
> - XML不是用来取代HTML的，它是HTML的补充，XML 把数据从 HTML 分离，通过使用几行 JavaScript，你就可以读取一个外部 XML 文件，然后更新 HTML 中的数据内容。
> - JSON相对于XML来讲，数据的体积小，传递的速度更快些



> 学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。下面我们就来了解下这三门技术都是用来实现什么的：
> 1. HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。
> 2. CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现，CSS是HTML的化妆师
> 3. JavaScript是嵌入在HTML中在浏览器中的脚本语言，具有与java和C语言类似的语言，一种网页的编程技术，用来向HTML页面添加交互行为，直接嵌入HTML页面，由浏览器解释执行代码，不进行预编译。用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。



> JQuery是一个优秀的JavaScript框架，一个轻量级的JS库，它封装了JS,CSS,DOM提供了一致的，简洁的API,使用户更加方便的处理HTML，实现动画效果，并且方便为网站提供Ajax交互模型，使用户的HTML页面保持代码和HTML内容分离



> CSS样式只有应用到HTML元素中，样式才会产生效果。有三种方式可以把CSS样式应用到HTML元素。
>
> - 一种方式是利用HTML元素的style属性，样式表作为style属性的值，该方式也称为行内样式；
> - 一种方式是将样式表放置在HTML网页文档head标签内，每个样式表赋予一个名称，然后在HTML元素中通过class属性引入样式表，该方式也称为内部样式；
> - 再一种方式是单独将样式表写入到一个文件，文件的扩展名为css，然后通过HTML的link标签链接外部样式表文件，在HTML元素中通过class属性引入样式表文件中的样式表，该方式也称为外部样式。



css用link（或style）， js用script标签，在html文件里都可以找到。

这个骆昊也没写完，只列了个框架，我也就随便看看，了解这个是怎么回事，不可能去钻研对吧。增加知识的广度。



## 2021.3.1

### day31-35 玩转Linux操作系统

通篇看下来，基本都了解

### day36-38 关系数据库入门

优化这种层面的理论知识就不用说了，最基本的SQL语句我都记忆模糊，只能说大致能够知道数据库是个什么东西吧...就像刚去武汉时候C语言一样，实在是不能直视，刚进东忠时候...大一学过的C语言...

> 在Python 3中，我们通常使用纯Python的三方库PyMySQL来访问MySQL数据库，它应该是目前Python操作MySQL数据库最好的选择。

讲道理，全面讲数据库这个三天不太够...

### day39-40 NoSQL入门

> NoSQL是一项全新的数据库革命性运动，虽然它的历史可以追溯到1998年，但是NoSQL真正深入人心并得到广泛的应用是在进入大数据时候以后，业界普遍认为NoSQL是更适合大数据存储的技术方案，这才使得NoSQL的发展达到了前所未有的高度。

介绍了Redis和MongoDB两种非关系型数据库...以及python中的库。前所未闻...

## 2021.3.3

### day41 Django快速上手

> 所谓Web框架，就是用于开发Web服务器端应用的基础设施，说得通俗一点就是一系列封装好的模块和工具。事实上，即便没有Web框架，我们仍然可以通过socket来开发Web服务器端应用，但是这样做的成本和代价在商业项目中通常是不能接受的。通过Web框架，我们可以化繁为简，降低创建、更新、扩展应用程序的工作量。刚才我们说到Python有上百个Web框架，这些框架包括Django、Flask等。

> Django框架在2005年夏天作为开源框架发布，使用Django框架能用很短的时间构建出功能完备的网站，因为它代替程序员完成了那些重复乏味的劳动，剩下真正有意义的核心业务给程序员来开发，这一点就是对DRY（Don't Repeat Yourself）理念的最好践行。



如何在pycharm中打开terminal:View ->Tool Windows->terminals

> localhost: 在过去它指向 127.0.0.1 这个IP地址。在操作系统支持 ipv6 后，它同时还指向 ipv6 的地址 [::1] 。localhost不是一个IP地址，而是一个域名，因而具有更多的意义。它用于指代this computer或者this host，可以用来获取运行在本机上的网络服务
>
> 127.0.0.1: 本机地址
>
> 192.168.1.xxx: 本机IP地址

127.x.x.x和0.0.0.0都是属于特殊情况的IP地址



> 我们可以提前准备一个模板页（MTV中的T），所谓模板页就是一个带占位符和模板指令的HTML页面。

> Django框架中有一个名为`render`的便捷函数可以来完成渲染模板的操作。所谓的渲染就是用数据替换掉模板页中的模板指令和占位符，当然这里的渲染称为后端渲染，即在服务器端完成页面的渲染再输出到浏览器中。后端渲染的做法在Web应用的访问量较大时，会让服务器承受较大的负担，所以越来越多的Web应用会选择前端渲染的方式，即服务器只提供页面所需的数据（通常是JSON格式），在浏览器中通过JavaScript代码获取这些数据并渲染页面上。

这就是CSS的工作吧，还分后端渲染和前端渲染，有意思！！！

> 至此，我们已经利用Django框架完成了一个非常小的Web应用，虽然它并没有任何的实际价值，但是可以通过这个项目对Django框架有一个感性的认识。

棒！这比浙大python课什么的好太多了。

### day42 深入模型

数据持久化的方式：配置MySQL； 然后通过ORM来适配Python程序

> Django框架提供了ORM来解决数据持久化问题，ORM翻译成中文叫“对象关系映射”。因为Python是面向对象的编程语言，我们在Python程序中使用对象模型来保存数据，而关系型数据库使用关系模型，用二维表来保存数据，这两种模型并不匹配。使用ORM是为了实现对象模型到关系模型的**双向转换**，这样就不用在Python代码中书写SQL语句和游标操作，因为这些都会由ORM自动完成。



> 修改`polls/views.py`文件，编写视图函数实现对学科页和老师页的渲染。

也就是说准备好html文件，不用CSS，直接用python编写视图函数来后端渲染

### day43 静态资源和Ajax请求

> 我们将静态资源置于名为`static`的文件夹中，在该文件夹包含了三个子文件夹：css、js和images，分别用来保存外部CSS文件、外部JavaScript文件和图片资源

终究还是靠CSS，JS来渲染搞动态

> 项目正式部署到线上环境后，通常会把静态资源交给专门的静态资源服务器（如Nginx、Apache）来处理，而不是有运行Python代码的服务器来管理静态资

> 使用Ajax技术可以在不重新加载整个页面的情况下对页面进行局部刷新。在使用Ajax技术时，浏览器跟服务器通常会交换XML或JSON格式的数据，XML是以前使用得非常多的一种数据格式，近年来几乎已经完全被JSON取代

## 2021.3.10

### day44 Cookie和Session

> Python标准库中的`hashlib`模块封装了常用的哈希算法，包括：MD5、SHA1、SHA256等。

用于用户登录

> 对一个Web应用来说，用户登录成功后必然要让服务器能够记住该用户已经登录，这样服务器才能为这个用户提供更好的服务，而且上面说到的CSRF也是通过钓鱼网站来套取用户登录信息进行恶意操作的攻击手段，这些都是以用户跟踪技术为基础的。

可以用表单中生成一个随机令牌（token）来防范

> 在服务器端，我们想记住一个用户最简单的办法就是创建一个对象，通过这个对象就可以把用户相关的信息都保存起来，这个对象就是我们常说的session（用户会话对象）。
>
> 我们可以给每个session对象分配一个全局唯一的标识符来识别session对象，我们姑且称之为sessionid，每次客户端发起请求时，只要携带上这个sessionid，就有办法找到与之对应的session对象，从而实现在两次请求之间记住该用户的信息，也就是我们之前说的用户跟踪。

session id这个跟我目前工作中有一丁点关联，说到底SCP也是客户端和服务端的通信嘛

让客户端记住并在每次请求时带上sessionid：本地存储。现在的浏览器都支持多种本地存储方案，比如：cookie

### day45-47 报表,日志和中间件

导出excel，pdf中的数据

> 采集日志数据也是为网站做数字化运营奠定一个基础，通过对系统运行日志的分析，我们可以监测网站的流量以及流量分布，同时还可以挖掘出用户的使用习惯和行为模式。

### day48-50 RESTful架构和DRF入门

> 在传统的Web应用开发中，大多数的程序员会将浏览器作为前后端的分界线。将浏览器中为用户进行页面展示的部分称之为前端，而将运行在服务器为前端提供业务逻辑和数据准备的所有代码统称为后端。

数据库表=》ORM=》python对象=》`bpmappers`=》json数据=》WebAPI

> 通过前端框架Vue.js来实现页面的渲染

可以理解为javascript的一个库？

> 前后端分离的开发需要将前端页面作为静态资源进行部署，项目实际上线的时候，我们会对整个Web应用进行动静分离，静态资源通过Nginx或Apache服务器进行部署

**php是服务端语言**:php在服务端做的事为：用户认证，自定义网站内容，处理请求

**javascript是客户端语言**:工作在浏览器端的脚本语言

Apache+PHP+MySQL:搭建服务器

> Python主要提供的框架有Django、Flask等。PHP的框架有Kohana、Symfony、CodeIgniter和Zend。

PHP对标的语言不是js，而是python...

> 显然，基于session实现用户跟踪的方式需要服务器保存session对象，在做水平扩展增加新的服务器节点时，需要复制和同步session对象，这显然是非常麻烦的。解决这个问题有两种方案，一种是架设缓存服务器（如Redis），让多个服务器节点共享缓存服务并将session对象直接置于缓存服务器中；另一种方式放弃基于session的用户跟踪，使用**基于token的用户跟踪**。

Redis是一种缓存服务器

> 简单的说RESTful架构就是：“每一个URI代表一种资源，客户端通过四个HTTP动词，对服务器端资源进行操作，实现资源的表现层状态转移”。REST被认为是最适合互联网应用的架构
>
> 在Django项目中，如果要实现REST架构，即将网站的资源发布成REST风格的API接口，可以使用著名的三方库`djangorestframework` ，我们通常将其简称为DRF。

### day51-55

> 通常情况下，Web应用的性能瓶颈都会出现在关系型数据库上，当并发访问量较大时，如果所有的请求都需要通过关系型数据库完成数据持久化操作，那么数据库一定会不堪重负。优化Web应用性能最为重要的一点就是使用缓存，把那些数据体量不大但访问频率非常高的数据提前加载到缓存服务器中，这又是典型的空间换时间的方法。通常缓存服务器都是直接将数据置于内存中而且使用了非常高效的数据存取策略（哈希存储、键值对方式等），在读写性能上远远优于关系型数据库的，因此我们可以让Web应用接入缓存服务器来优化其性能，其中一个非常好的选择就是使用Redis。

Web开发真的是可以很深，吃经验。

## 2021.3.11

### day51-65 网络爬虫

> 网络爬虫（web crawler），以前经常称之为网络蜘蛛（spider），是按照一定的规则自动浏览万维网并获取信息的机器人程序（或脚本），曾经被广泛的应用于互联网搜索引擎。

百度搜索引擎本质上就是个 Baiduspider。大多数网站都会定义robots.txt文件,淘宝在这个文件里不允许百度访问它的产品，因为是Open API,所以只能是百度自觉遵守

```
User-agent: Baiduspider
Disallow: /

User-agent: baiduspider
Disallow: /
```

打入https://www.taobao.com/robots.txt可以直接获取，可以发现它就对百度做了限制...

介绍了使用requests库获取页面

```
requests.get('https://github.com', timeout=10)

Keep-Alive: timeout=5, max=100
```

所以timeout，keepalive这些都是网络通信的基础，现在的工作中多少也有些

抓取页面之后可以用正则表达式或其他库对html进行解析，前者肯定可读性差一点，但快

## 2021.3.12

### day66-70 数据分析

概率论，线性代数等等，其实高等教育其实把人类文明中顶端的基础知识给普及了。

### day71-85 人工智能和机器学习

> 机器学习是实现人工智能的一种途径
>
> “人脑”在处理模糊输入信息时表现出来的强大处理能力，在很多场景下“电脑”是难以企及的。所以我们研究机器学习的算法，就是要解决在输入模糊信息时让计算机给出满意解甚至是最优解的问题。

一大堆专业词汇吓退一大堆人，真的去看一看吴恩达的机器学习课程？？

### day86-90 大数据

### day91-100

> 对于有使用Subversion（以下简称为SVN）经验的人来说，Git和SVN的共同点是摒弃了传统的基于锁定模式的版本控制（早期的CVS和VSS使用了锁定模式，当一个开发者编辑一个文件时会锁定该文件，其他开发者在此期间无法编辑该文件），采用了更有效率的基于合并模式的版本控制，而二者的区别在于：
>
> 总而言之，**Git真的非常棒！！！**

Docker容器与虚拟机的异同点

#### 使用Django开发商业项目

MVC架构：model+controller+view 完全是个后端框架

数据模型model：关系型数据库通过ORM转化为python对象

视图函数(Controller)：

模板(View)：

> omcat是一个web应用服务器，能够解析静态文件和动态文件（如：html、jsp、servlet等）；apache是一个web server，能够解析静态文件。Tomcat作为一个独立的web服务器是可以使用的，但是它对静态文件的解析能力不如apache，所以就产生现在的web应用的分布式部署，apache+tomcat。

> 主流的网站基本采用：lamp/lnmp方式部署web服务器（l——linux，a——apache，n——nginx，m——mysql，p——php）

> Apache是web服务器（静态解析，如HTML），tomcat是java应用服务器（动态解析，如JSP(Java Server Page)）.
>
> JSP 通过网页表单获取用户输入的数据、访问数据库以及其他数据源，然后动态的创建网页。JSP 文件的后缀名是 `.jsp`。从上面看JSP特色就是 JAVA+大段的HTML，书写起来确实方便了很多。
>
> JSP：Java平台，安全性高，适合开发大型的，企业级的Web应用程序。
>
> JSP运行在后台服务器上，混合在HTML中的java程序段用于控制HTML的动态生成，并且通常负责调用后台数据库中的数据，形成能够根据使用情况的变化的，具有丰富数据交互效果的页面。
> JavaScript 通常是运行在前台，即运行于用户浏览器的，通常不需要服务器的后台支持（AJAX交互例外），混合在HTML中的JavaScript脚本程序直接被浏览器解释执行，以提高页面的美观性和UI操作响应速度为基本目标。
>
> PHP：简单、高效、成本低，开发周期短，特别适合中小型企业的Web应用开发。（LAMP：Linux+Apache+MySQL+PHP）
>
> Tomcat只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行.
>
> Apache是普通服务器，本身只支持html即普通网页，可以通过插件支持php，还可以与Tomcat连通
>
> 如果客户端请求的是静态页面，则只需要Apache服务器响应请求；如果客户端请求动态页面，则是Tomcat服务器响应请求，将解析的JSP等网页代码解析后回传给Apache服务器，再经Apache返回给浏览器端。
>
> Tomcat虽然是一个servlet和jsp容器，但是它也是一个轻量级的web服务器。它既可以处理动态内容，也可以处理静态内容。不过，tomcat的最大优势在于处理动态请求，处理静态内容的能力不如apache和nginx
>
> PHP主要使用的是Apache服务器,另外，还有一些其它的PHP服务器软件，如德国的lighttpd，俄国的nginx。

首先Linux+Apache/Nginx+MySQL+PHP,关键就是PHP在这里的定位是什么？应该是与java和python一样，实在web服务器上去做比如controller程序的语言，而java而来的JSP它需要tomcat去解析，所以java写服务器就需要apache+tomcat？。至于html，js，css那是浏览器端范畴的语言就完全不一样。

