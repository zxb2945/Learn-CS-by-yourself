# LeetCode100题 （C#）

> **数组-> 链表-> 哈希表->字符串->栈与队列->树->回溯->贪心->动态规划->图论->高级数据结构，由浅入深，层层递进。**

LeetCode算法题推荐： [Link](https://www.zhihu.com/question/26160121/answer/2044426936)



# 算法

## 第一章 基础

### 1.1 基础编程模型 20240508

#### 1.1.1 Java程序的基本结构

#### 1.1.2 原始数据类型与表达式

> 首先考虑以下4 种Java 语言**最基本的原始数据类型**：
>  整型，及其算术运算符（int）；
>  双精度实数类型，及其算术运算符（double）；
>  布尔型，它的值 {true, false}及其逻辑操作（boolean）；
>  字符型，它的值是你能够输入的英文字母数字字符和符号（char）。

最基本的就四种啦

> 为了提供更大的灵活性，Java 还提供了其他五种原始数据类型：
>  64 位整数，及其算术运算符 (long)；
>  16 位整数，及其算术运算符 (short)；
>  16 位字符，及其算术运算符 (char)；
>  8 位整数，及其算术运算符 (byte)；
>  32 位单精度实数，及其算术运算符 (float)。

#### 1.1.3 语句

#### 1.1.4 简便记法

#### 1.1.5 数组

#### 1.1.6 静态方法

> 我们会经常使用递归，因为递归代码比相应的非递归代码更加简洁优雅、易懂。
>
> 递归总有一个最简单的情况——方法的第一条语句总是一个包含return的条件语句。

#### 1.1.7 API

> 方法库会经过大量测试，覆盖极端和罕见的情况，是我们可以信任的。

比如java.lang 中Math库

#### 1.1.8 字符串

#### 1.1.9 输入输出

#### 1.1.10 二分查找

#### 1.1.11 展望

### 1.2 数据抽象 20240508

#### 1.2.1 使用数据抽象类型

#### 1.2.2 抽象数据类型举例

#### 1.2.3 抽象数据类型的实现

#### 1.2.4 更多抽象数据类型的实现

#### 1.2.5 数据类型的设计

### 1.3 背包，队列和栈 20240509

#### 1.3.1 API

#### 1.3.2 集合类数据类型的实现

#### 1.3.3 链表

#### 1.3.4 综述

> 我们现在拥有两种表示对象集合的方式，即数组和链表。Java 内置了数组，
> 链表也很容易使用Java 的标准方法实现。**两者都非常基础，常常被称为顺序存储和链式存储。**

**Stack** 和 **Queue** 都可以基于 **数组** 或 **链表** 实现.

本章简而言之就是，底层两种数据结构 数组和链表，在这两者基础上可以构造出 Stack和Queure两种高级API

### 1.4 算法分析 20240509

#### 1.4.1 科学方法

#### 1.4.2 观察

#### 1.4.3 数学模型

#### 1.4.4 增长数量级的分类

常数级别，对数级别 logN，线性级别，线性对数级别，平方级别，立方级别，指数级别

| 描述         | 数量级   | 举例                |
| ------------ | -------- | ------------------- |
| 常数级别     | O(1)     | 两数相加 a = b + c; |
| 对数级别     | O(logN)  | 二分查找            |
| 线性级别     | O(n)     | 单层循环            |
| 线性对数级别 | O(nlogn) | 分治，归并排序      |
| 平方级别     | O(n^2)   | 双层循环            |
| 立方级别     | N^3      | 三层循环            |
| 指数级别     | O(2^n)   | 穷举查找            |
|              |          |                     |

> 使用最广泛的记法是“大O” =>“大Omega”记法通常用来表示最坏情况下的性能下限
>
> **O(f(n))** 表示随着输入数据量 n 增加，算法的复杂度增长的上界。也就是说，O符号描述的是在最坏情况下，算法执行所需的时间或空间的最大增长率。

O(n log n) 比O(n²)要快，但比O(n)慢，通常是排序和分治算法的复杂度。=>经验之谈，希望之后有机会验证，验证个屁...不是理所当然的事情嘛...

大O符号 => Big O notation 

> 所以如果你想说 **"O(n)"** 的时间复杂度，通常会说：
>
> - "Big O of n"或 "O of n"
>
>   。例如：
>
>   - **O(1)**：**"Big O of one"** 或 **"O of one"**。
>   - **O(n)**：**"Big O of n"** 或 **"O of n"**。
>   - **O(n log n)**：**"Big O of n log n"** 或 **"O of n log n"**。
>   - **O(n²)**：**"Big O of n squared"** 或 **"O of n squared"**。

面试的时候算法分析这个是基础啊，上次 两层循环 Big O of n squared 还想了半天，不应该啊！！下次LeetCode刷算法，没写一个，注释一下时间复杂度哈

#### 1.4.5 设计更快的算法

#### 1.4.6 倍率实验

#### 1.4.7 注意事项

#### 1.4.8 处理对于输入的依赖

#### 1.4.9 内存

#### 1.4.10 展望

> 在编程领域中，最常见的错误或许就是过于关注程序的性能。你的首要任务应该是写出清晰正确的代码。仅仅为了提高运行速度而修改程序的事最好留给专家们来做。事实上，这么做常常会降低生产效率，因为它会产生复杂而难以理解的代码。C.A.R. Hoare（快速排序的发明人，也是一位推动编写清晰而正确的代码的领军人物）曾将这种想法总结为：“不成熟的优化是所有罪恶之源。”Knuth 为这句话加上了一个定语“在编程领域中（或者至少是大部分罪恶）”。另外，如果降低成本带来的效益并不明显，那么对运行时间的改进就不值得了

### 1.5 案例研究：union-find算法 20240522

#### 1.5.1 动态连通性

> 众所周知，数据结构的性质将直接影响到算法的效率，因此数据结构和算法的设计是紧密相关的

#### 1.5.2 实现

quick-find 算法

quick-union 算法

#### 1.5.3 展望

## 第二章 排序

> 在计算时代早期，大家普遍认为30% 的计算周期都用在了排序上。如果今天这个比例降低了，可能的原因之一是如今的排序算法更加高效，而并非排序的重要性降低了。现在计算机的广泛使用使得数据无处不在，而整理数据的第一步通常就是进行排序

### 2.1 初级排序算法 20240524

#### 2.1.1 游戏规则

#### 2.1.2 选择排序

> 一种最简单的排序算法是这样的：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。
>
> 总的来说，选择排序是一种很容易理解和实现的简单排序算法，它有两个很鲜明的特点。
>
> 运行时间和输入无关；
>
> 数据移动是最少；

#### 2.1.3 插入排序

> 通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。
>
> 总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组。

#### 2.1.4 排序算法的可视化

#### 2.1.5 比较两种排序算法

#### 2.1.6 希尔排序

> 希尔排序的思想是使数组中任意间隔为h 的元素都是有序的。
>
> 希尔排序更高效的原因是它权衡了子数组的规模和有序性。
>
> 透彻理解希尔排序的性能至今仍然是一项挑战。

> 如果你需要解决一个排序问题而又没有系统排序函数可用（例如直接接触硬件或是运行于嵌入式系统中的代
> 码），可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。

### 2.2 归并排序 20240529

> 归并排序最吸引人的性质是它能够保证将任意长度为N 的数组排序所需时间和NlogN 成正比；它的主要缺点
> 则是它所需的额外空间和N 成正比。

相比较之下，无论是选择排序还是插入排序 都是 O(n^2)

#### 2.2.1 原地归并的抽象方法

#### 2.2.2 自顶向下的归并算法

> 递归实现的归并排序是算法设计中分治思想的典型应用。

#### 2.2.3 自底向上的归并排序

#### 2.2.4 排序算法的复杂度

### 2.3 快速排序 20240529

#### 2.3.1 基本算法

> 快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。

#### 2.3.2 性能特点

#### 2.3.3 算法改进

> Dijkstra

> 经过精心调优的快速排序在绝大多数计算机上的绝大多数应用中都会比其他基于比较的排序算
> 法更快。快速排序在今天的计算机业界中的广泛应用正是因为我们讨论过的数学模型说明了它在实
> 际应用中比其他方法的性能更好，而近几十年的大量实验和经验也证明了这个结论。

### 2.4 优先队列 20240529

#### 2.4.1 API 

> 优先队列是一种抽象数据类型

#### 2.4.2 初级实现

#### 2.4.3 堆的定义

> 数据结构二叉堆能够很好地实现优先队列的基本操作。

#### 2.4.4 堆的算法

#### 2.4.5 堆排序

### 2.5 应用 20240605

> 排序如此有用的一个主要原因是，在一个有序的数组中查找一个元素要比在一个无序的数组中查找简单得多。

排序终究还是为查找服务的

#### 2.5.1 将各种数据排序

#### 2.5.2 我应该使用哪种排序算法

> 你会发现Java 的Arrays.sort() 实现（可能再加上你自己实现的compareTo() 或者compare()）已经基本够用了，因为它使用的三向快速排序和归并排序都是经典。

编程语言自带的排序通常 就是选择 归并排序， O(nlogn)

#### 2.5.3 问题的归约

#### 2.5.4 排序应用一览

## 第三章 查找

### 3.1 符号表 20240605

#### 3.1.1 API

#### 3.1.2 有序符号表

#### 3.1.3 用例举例

#### 3.1.4 无序链表中的顺序查找

#### 3.1.5 有序数组中的二分查找

#### 3.1.6 对二分查找的分析

> rank() 的递归实现还能够让我们立即得到一个结论：二分查找很快，因为递归关系可以说明算法所需比较次数的上界。

#### 3.1.7 预览

> 要支持高效的插入操作，我们似乎需要一种链式结构。但单链接的链表是无法使用二分查找法的，因为二分查找的高效来自于能够快速通过索引取得任何子数组的中间元素（但得到一条链表的中间元素的唯一方法只能是沿链表遍历）。为了将二分查找的效率和链表的灵活性结合起来，我们需要更加复杂的数据结构。能够同时拥有两者的就是二叉查找树

| 使用的数据结构             | 优点                     |
| :------------------------- | ------------------------ |
| 链表（顺序查找）           | 适用于小型问题           |
| 有序数组（二分查找）       | 最优的查找效率和空间需求 |
| 二叉查找树BST              |                          |
| 平衡二叉查找树 RedBlackBST | 最优的查找效率和插入效率 |
| 散列表                     |                          |

### 3.2 二叉查找树 20241213

> 将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。

#### 3.2.1 基本实现

#### 3.2.2 分析

#### 3.2.3 有序性相关的方法与删除操作

### 3.3 平衡查找树 20241213

#### 3.3.1 2-3查找树

#### 3.3.2 红黑二叉查找树

#### 3.3.3 实现

#### 3.3.4 删除操作

#### 3.3.5 红黑树的性质

