# 操作系统（哈工大李治军）

课程视频地址：https://www.bilibili.com/video/BV1d4411v7u7

## 1 OS,What? 20210220

操作系统要去管理CPU，内存，以及各种IO设备，然而其自身又是放在内存里的，靠CPU来运行的...这就像集合论的悖论...

## 2 Open the OS 20210220

白纸--图灵机--通用图灵机--计算机

冯诺依曼存储思想：取指执行

x86PC开机就会有一段代码，去检查硬件。

引导扇区代码是一段汇编代码bootsect.s。

抓住操作系统代码的主干。

boot工作：读setup，读system...



打开电源，计算机执行的第一句指令是什么？

开机时，CPU首先处于一个实模式(不是保护模式)，内存里有一段固化代码BIOS(基本输如输出系统)，否则冯诺依曼的取值执行就没有入口...  CS就是段地址，IP就是偏移量，这两个值有初始值CS=0xFFFF,IP=0X0000，开始检查各种硬件设备，然后去磁盘读入操作系统第一段代码放到内存中的0x7c00这个位置。然后操作系统的故事就开始了

硬盘的第一个扇区上存放着开机后我们可以执行的第一段代码bootsect.s

然后在把0x7c00读取的第一段512字节代码移到0x90000处（为了腾出空间），继续顺序往下执行

int 0x13是BIOS读磁盘的中断，然后读操作系统接下来的代码setup部分，调用有中断int 0x10,打出字符"Loading system",然后继续用13中断读更多的操作系统代码

接下来bootsect.s把控制权给setup，即跳转代码

## 3 Power On  20210224

bootsect.s打出开机logo，然后调用系统中断，载入系统

开篇读各种汇编...setup.s将完成OS启动前的设置，获取机器的内存大小，OS开始接管各种硬件

实模式到保护模式的切换：寻址模式从16位汇编代码转到32位汇编代码   -》就是说保护模式就是32为寻址模式，实质上CPU的解释模式不同，走另一条电线。

setup是进入保护模式，head是进入后的初始化。

操作系统是一个永不停机的程序：进入main函数，开始C语言程序

boot.s->setup.s->head.s->main.c->mem_init.c...

操作系统是管理计算机硬件的程序







## 4 OS Interface 20210227

用户使用计算机方式：命令行，图形按钮，应用程序

想知道一些基础库，比如贪吃蛇图形，它是怎么去操作屏幕的？=》普通C语言函数+操作系统接口

操作系统接口：接口表现为函数调用，又由系统提供，所以称为系统调用 (system call)

printf 其实是包装了write函数

fork，pthread_create,open等就是系统调用

操作系统支持POSIX接口(X指Unix)，可以上网查这个手册

## 5 Syetem Call 20210301

whoami()  是一个系统调用哦

内核态和用户态

主动进入内核的方法：对于intel x86，那就是中断指令int 0x80

(直接讲解linux内核源码了)

printf调用实质是write系统调用，通过内嵌汇编，其核心就是int 0x80

printf用户调用-》展开成int 0x80=》system_call-》查table=》调用sys_write



内核态可以访问任何段数据，用户态不可以访问内核段代码。

内核态，用户态是处理器的一种硬件设计模式

将内核程序和用户程序隔离



而内核段程序是操作系统其中最核心的一部分代码

## 6 History of OS 20210303

多进程管理,分时系统：timesharing (1965-1980)

UNIX(1980-1990)

1.实现操作系统的多进程图谱：CPU和内存；2.实现操作系统的文件操作视图：IO操作（系统调用），磁盘，文件。

操作系统管理硬件：

## 7 Our Objects 20210303

进程view： CPU管理，内存管理

File view： 磁盘管理，终端设备管理

open一个硬件设备文件发生什么事？之后的内容...一个设备时怎样驱动的？

## 8 CPU管理的直观想法20210308

CPU和内存通过总线通信

CPU自动从内存取指执行，PC中的地址设置初值50之后自动累积

IO指令执行起来是一般指令的10的6次方倍

多道程序，交替执行，好东西啊！=》并发

每个程序有一个存放信息的结构：PCB（寄存器信息等）

## 9 Multiple Process 20210310

main中最后fork()创建了第一个进程，里面init执行了shell(Windows桌面)。

shell的核心代码就是scanf获得一个cmd，然后fork一个新的进程，exec(cmd).

=》fork是父子进程，exec是新进程

进程切换：schedule()

调度和切换

内存管理：通过映射表来对多进程地址进行空间分离



我在想：tcp三次握手不是在内核中完成的嘛，有可能不是专门的进程去处理它，而是操作系统本身去处理它，因为操作系统概念上还是要高于进程这个概念的。

## 10 User Threads 20210320

进程到线程的说明，这个现在看就太熟悉了...但两年前还不算太熟...许多概念就既定了，但是看这个课程循循诱导其实还是非常不错的，为什么从进程到线程，线程为什么不能用同一个栈...等等...所以这门课好对吧

线程怎样切换？？（切换是操作系统的核心）

核心是 yield()  ： 这个函数是去修改PC寄存器，那似乎就必须用汇编来写啊...（不是的）

线程各自有栈，就需要存放栈信息，类似PCB创建一个全局变量TCB： thread control block

ThreadCreate 的核心就是用程序做出这三样东西：TCB，栈， 切换的PC在栈中

TCB，栈什么的 都是用malloc()申请的？My God...

注意以上所讲的是用户级线程的创建和切换，并不进去内核态，可以单独使用，事实上可以不涉及操作系统，就是应用层序层面的。（类似于协程？？想起Python中的yield...是否有关联？？？）

内核级线程相对于用户级线程并发性要更好，为什么呢？因为后者比如应用于浏览器，接受URL时候，就要调用硬件IO，穿过内核时，内核直接调度到其它进程去了，导致浏览器所有线程都阻塞住，所有页面都卡住（如果浏览器是用户级线程来表示每一个页面的设计的话，然后chrome似乎是多进程设计，就没有这个问题，但是超耗内存）。

用户级线程yield()在内核线程里叫schedule(),可以从英文字面上理解其差异。

## 11 Kernel Threads 20210321

进程没有用户态进程这一说法，所有进程都是内核态的，因为进程需要分配内存资源，这是与硬件打交道的，必须进入内核态。

多核要发挥作用，必须支持核心级线程：

每个进程都有自己的一套映射表MMU和缓存cache，所以对于多核处理器而言，它虽然有多个CPU，但它们都是相同的地址映射和缓存，所以多进程没法体现其优势，而多线程则可以。

=》首先要清楚，多核与多处理器的区别，两者均有多个CPU，但是前者多个CPU用同一套cache和MMU，而后者每个CPU都用不同的cache和MMU，所以多核对于多进程并行没什么鸟用，每换个线程都要切换cache和MMU，完全发挥不出多核的优势，而核心级线程就可以完美适配多核。

=》其次清楚并发与并行的却别，并发指同时出发，交替执行，并行是同时执行。

> 　**线程是CPU调度和分配的基本单位**，一定要和 **进程是操作系统进行资源分配（包括cpu、内存、磁盘IO等）的最小单位** 区别清楚。有句话说CPU只能看到线程，可以这么理解，假设我是CPU，我闭着眼，操作系统调度器将一个进程分配给我之后，我拿到进程睁开眼，我看到的是什么？我看到的是进程中的很多线程，那么我现在能调度和分配的是什么？进程？不行，因为我看不到其他进程，何来调度分配，只能调度我看到的那些线程，如果我是4核的话，把线程ABCD分配到核心1234，其他的线程依然要等待分配，至于等待多久，如何分配，暂不在本文讨论范围。于是线程是CPU调度和分配的基本单位。
>
> 　**总结：**
>
> 　　**1、单CPU中进程只能是并发，多CPU计算机中进程可以并行。**
>
> 　　**2、单CPU单核中线程只能并发，单CPU多核中线程可以并行。**
>
> 　　**3、无论是并发还是并行，使用者来看，看到的是多进程，多线程。**

对于核心级线程而言，不仅在用户态有一个栈，内核态也要有一个栈，所以从一个栈到了一套栈。

用户态栈跟内核态栈存储的信息组成一个完整的中断栈信息，不是copy一份，一般来说就在内核态进行一小部分马上又出去到用户态执行了。

内核线程switch：先从用户栈进入内核态，再到TCB，然后切换TCB，根据TCB，先切换内核态栈，然后根据内核态栈，再出来切换用户态栈

所以在ThreadCreate中一套栈都要初始化

注意核心级线程与核心级+用户级复合线程的区别。后者应该才是最有效率的形态。因为纯核心级线程毕竟资源有限，不像用户级线程理论上可以创建无数个。

## 12 Create Kernel Threads2021032

Create Kernel Threads

学会内核级线程的切换的代码实现，是进程的切换的基础

=》进程切换就是指令切换和内存资源切换，前者跟核心级线程切换一样

栈虽然有两个，但TCB理所当然只有一个。

fork()->INT 0x80 + 系统调用号 -> _system_call ->sys_fork

线程的切换契机：比如说时间片用完或者堵塞

利用一个调度算法找到要切换的线程开始切换

fork就是叉子，上下父子线程。

fork()中的copy_process中的主要内容：申请内存空间，不用malloc，因为它是申请用户态内存的；创建TCB；创建内核栈和用户栈；关联栈和TCB。

父子线程的内核栈不同，用户栈可能相同

父子线程eax寄存器值不同，即fork()返回值不同，用此来区分父子进程。开个叉分，各自执行不同代码。



### Linux 线程实现机制分析

> 在核外实现的线程又可以分为"一对一"、"多对一"两种模型，前者用一个核心进程（也许是轻量进程）对应一个线程，将线程调度等同于进程调度，交给核心完成，而后者则完全在核外实现多线程，调度也在用户态完成。后者就是前面提到的单纯的用户级线程模型的实现方式，显然，这种核外的线程调度器实际上只需要完成线程运行栈的切换，调度开销非常小，但同时因为核心信号（无论是同步的还是异步的）都是以进程为单位的，因而无法定位到线程，所以这种实现方式不能用于多处理器系统，而这个需求正变得越来越大，因此，在现实中，纯用户级线程的实现，除算法研究目的以外，几乎已经消失了。

> Linux内核只提供了轻量进程的支持，限制了更高效的线程模型的实现，但Linux着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。目前最流行的线程机制LinuxThreads所采用的就是线程-进程"一对一"模型，调度交给核心，而在用户级实现一个包括信号处理在内的线程管理机制。

> "一对一"模型的好处之一是线程的调度由核心完成了，而其他诸如线程取消、线程间的同步等工作，都是在核外线程库中完成的。在LinuxThreads中，专门为每一个进程构造了一个管理线程，负责处理线程相关的管理工作。当进程第一次调用pthread_create()创建一个线程的时候就会创建（__clone()）并启动管理线程。

> 由于Linux内核的限制以及实现难度等等原因，LinuxThreads并不是完全POSIX兼容的，在它的发行README中有说明：**进程id问题**，这些轻量级进程拥有独立的进程id，在程调度、信号处理、IO等方面享有与普通进程一样的能力 ；**信号处理问题**，由于异步信号是内核以进程为单位分发的，而LinuxThreads的每个线程对内核来说都是一个进程，且没有实现"线程组"，因此，某些语义不符合POSIX标准，比如没有实现向进程中所有线程发送信号；**线程总数问题**，LinuxThreads将每个进程的线程最大数目定义为1024，但实际上这个数值还受到整个系统的总进程数限制，这又是由于线程其实是核心进程。

> 一个是RedHat公司牵头研发的NPTL（Native Posix ThreadLibrary），在技术实现上，NPTL仍然采用1:1的线程模型，并配合glibc和最新的LinuxKernel2.5.x开发版在信号处理、线程同步、存储管理等多方面进行了优化。和LinuxThreads不同，NPTL没有使用管理线程，核心线程的管理直接放在核内进行，这也带了性能的优化。
>
> 主要是因为核心的问题，NPTL仍然不是100%POSIX兼容的，但就性能而言相对LinuxThreads已经有很大程度上的改进了。



## 13 The Tree of OS 20210322

操作系统核心就是CPU控制和内存管理，而CPU控制核心就是多进程管理

Linux Kernel Source Tree

CPU读PC指向的指令，依此向下开始操作；

多进程需要切换，要用栈做这件事；

一个栈会造成混乱，所以需要两个栈+两个TCB；

用户态切换有局限，所以要引进内核栈；

以上是idea构思。

最原始原始的Linux0.01是一个在屏幕上交替打出AB的OS。利用时钟中断调用schedule()

（有时间在LINUX编码一下if(!fork())的汇编是怎样的？）

ThreadCreate源码里面核心应该是fork()=》好像不是，彼此独立，后者更重要在于clone。

## 14 CPU Scheduling 20210324

## 15一个实际的schedule函数20210324

## 16 Processes Synchronization and Semaphore 20210325

semaphore

## 17 Critical Section 20210325

共享数据需要保护

共享数据所在那块区域就被称为Critical Section.

基本原则：mutual exclusion



感觉信号量的共享数据保护策略都在内核操作系统里实现了？



Peterson算法：信号量内部的算法策略，标记+轮转。这个一般来说就对coder是黑盒了。



硬件原子指令法：mutex一条指令一步完成不会被打断，binary semaphore没有这个性质？

所以mutex可以用来semaphore，而不会导致无限套娃，因为两者某种程度上是同一目的被设计的。



## 18 Coding Semaphore 20210325

## 19 Dead Lock 20210325

## 20 Memory and Segmentation 20210328

物理内存0地址放的是操作系统

一般的程序就选一段空的内存放进去，然后运行时重定位

内存中：

| 内存                 | 磁盘                             |
| -------------------- | -------------------------------- |
| 常驻程序（操作系统） |                                  |
| 进程1                | 有可能把内存中不用的进程交换出来 |
| 进程2                |                                  |
|                      |                                  |
|                      |                                  |

上图这个常驻系统难道就是内核了？？？

（内核态和用户态应该是CPU的两种状态之一，跟内存分布应该没关系吧？但是内核态确实是操作系统状态...保障应用程序只能通过跳转到操作系统代码的方式来切换到内核态上，这样也就间接保障了内核态下执行的都是操作系统（包括驱动）的代码。

但是内核态下都是运行的操作系统代码

内核态是一个状态，而不是一个位置。表示当前CPU在执行操作系统内核代码。内核态是操作系统的概念，CPU没有内核态一说。CPU有各种特权级，表示CPU的状态。一般来说操作系统内核态会在CPU的高特权级下执行，而应用程序会在CPU的低特权级下执行，这个是操作系统的逻辑决定的。）

> 这里再明确一个概念，每个进程都有一个4G大小的虚拟地址空间，在这个4G大小的虚拟地址空间中，前0～3G为用户空间，每个进程的用户空间之间是相互独立的，互不相干。而3G～4G为内核空间，因为每个进程都可以从用户态切换到内核态，因此，内核空间对于所有进程来说，可以说是共享的，不过这么说有些不太严谨，应该说内核空间中大部分区域对于所有的进程来说都是共享的，这不共享的小部分区域是存储所有进程内核栈的区域，为什么这么说，因为每个进程都存在一个内核栈，而各个进程的内核栈之间一定是不共享的。

是否可以这样理解：所有进程有其表层代码，和各种操作系统api构成，某种程度上说，操作系统的代码也是进程代码之一，而这操作系统的代码是放在内核空间的，对于每个进程都是虚拟地址嘛。这样说来这操作系统的确是非常极其特殊的一个程序，不是进程，合起来是个程序，又似乎分散于各种进程中...



## 21 Memory Partition and Paging 20210402

程序分段，内存分页

分区是对应虚拟内存，而分页针对实际内存

段以页的形式被打散到物理内存

## 22 Multilevel Paging 20210402

CPU要通过总线访问内存，这就花时间

页分得细，管理页的页表所占内存就大（因为理论上说，每个程序都包含了所有内存的地址），多打开几个程序就非常耗内存，所以像书在页上有章，计算机利用多级页表来减少载入内存的页表，简而言之，就是建立索引

实际上就是以时间换空间，多级页表增加了访问内存的次数

可以用寄存器快速访问经常访问的页表来加快速度，这就是快表的思想，有点像缓存的意思，因为程序内存访问具有局部性

最后就是：快表+多级页表的架构，充分体现了操作系统一种折中的思想，时间与空间

## 23 Segmentation & Paging 20210402

程序员希望用段，内存希望用页，段和页的结合就很重要

核心就是：虚拟内存

段面向用户，页面向硬件

fork():

1 分配虚存，建段表

2 分配内存，建页表

如果用软件负责逻辑内存，虚拟内存，实际内存之间的转化，非常费时间，所以CPU里设计了MMU这个硬件来负责转化

## 24 Swap in 20210404

是由虚拟内存引出来的

分段和分页是操作系统管理内存最重要的概念

由换入换出实现虚拟内存

请求时才从磁盘换入，并建立虚拟内存和物理内存的映射

代码中是逻辑地址，然后加上基址就成虚拟地址，然后映射成物理地址

执行请求地址，MMU查页表，发现缺页，就打个中断，内存就从磁盘换入

## 25 Swap out 20210404

换出就需要算法了，换哪一页出去？

操作系统中还是有许多算法要求的，进程调度，内存换出等。

磁盘专门有一个swap分区管理



内存换入换出-》虚拟内存=》段页=》操作系统管理内存=》程序载入=》实现多进程图像

加上初始化，系统接口辅助性模块，加上设备驱动和文件系统，整个计算机轮廓就出来了

内存管理和进程管理是操作系统的核心

## 26 printf(Display) 20210407

设备驱动程序：

CPU通过PCI总线发out指令给键盘寄存器，键盘就会根据寄存器内的指令做相关动作，然后给CPU发一个硬件中断

=》CPU通过PCI总线发out指令就是把内核缓存中的字符流mov过去嘛,out就是mov.

操作系统提供一个中间层在用户和硬件设备商之间：文件视图,不同的设备对应不同的文件名

不论什么设备，系统调用接口都是open,read,write,close.

printf其实最终转化为write

终端设备就是键盘和显示器

写设备驱动程序：根据设备信息，注册相应函数，放到表里，创建一个dev文件

外围的设备驱动程序也是kernel的一部分，相对进程管理和内存管理就简单很多

显存就是显示器的存储？

从缓存转移数据到显存最关键的就是out汇编指令？但是这里显示为mov，因为机组的相关知识这里有个区分

写外设最核心三条：CPU向外设控制器发出out指令；外设给CPU中断；提供给用户一个简单的文件视图。

## 27 Keyboard 20210407

写IO，其实就几条指令

CPU向控制器中的寄存器读写数据

控制器完成真正的工作，并向CPU发中断信号

做设备驱动，肯定要查硬件手册

设备驱动，要么CPU发指令，要么硬件发中断

最贴近硬件的C文件就直接内嵌汇编代码

## 28 Raw Disks 20210410

> BIOS一般被存放在ROM(只读存储芯片)之中，即使在关机或掉电以后，这些代码也不会消失。 

> RAM（random access memory）即随机存储内存
>
> ROM（Read-Only Memory）即只读内存，是一种只能读出事先所存数据的固态半导体存储器。

> 一般来说会比较难以理解RAM与ROM和平时所说的运行内存和硬盘容量有什么关系，其实从一般意义上来说是一样的，但从计算机和手机的角度来说又有一些区别：
> 从电脑来说一般比较好理解，RAM就是我们平时所说的运行内存，它的确是随时可读写的。因为CPU处理的数据都是以运行内存为中介的。断电后信息是不保存的。那么对于ROM来说，是不是就是硬盘呢？不是说ROM只可以读吗？硬盘却是可以修改的。的确，必须明确一点，RAM与ROM都是内存，而硬盘是外存，所以ROM不等于硬盘。计算机中的ROM主要是用来存储一些系统信息，或者启动程序BIOS程序，这些都是非常重要的，只可以读一般不能修改，断电也不会消失。
>
> 在手机里面，RAM就是跟电脑一样的运行内存一样；而ROM就跟硬盘挂上钩了，手机中的ROM有一部分用来存储系统信息，还有一些装机软件，剩余的大部分容量都是就是拿来作为硬盘用的，可读可写。
>
> Cache：高速缓冲存储器，也是我们经常遇到的概念，它位于CPU与内存之间，是一个读写速度比内存更快的存储器。
>
> ————————————————
> 版权声明：本文为CSDN博主「一只青木呀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/weixin_45309916/article/details/108808106



磁盘驱动代码最底层就是操作磁盘的磁道扇区，写入数据

通过盘块号读写磁盘（一层抽象）

磁生电，电生磁

多个进程通过队列使用磁盘（第二层抽象）

请求队列起个缓存作用

一旦使用文件系统使用磁盘，就变成熟磁盘了...

各种磁盘调度算法

## 29 Files-cooked Disks 20210413

盘块上引入更高层次的抽象概念--文件（第三层抽象）

用户眼里文件的本质就是字符流

文件：建立字符流到盘块集合的映射关系

操作系统负责维护这个映射关系

每个文件有一个File Control Block的数据结构表

文件会按特定组织方式放在磁盘上，比如连续结构，又如链式结构（适合像word这样不断增删改查的动态变化文件），索引结构（实际系统采用的，可以比较好兼顾速度和大文件）等



感慨：计算机行业是不断复杂累积，不断站在巨人肩膀上前进的一门科学，基础就是概括性的了解肩膀下面的学科层次。

## 30 Files Implementation 20210414

sys_write( int fd, ...)

看源代码可以看到，fd其实是一个数组下标数字，应该是一个索引值，根据这个可以找到磁盘块号，fd往下挖就是inode

=》就是inode是文件标识符(一个数据结构)，而fd则是放在进程里关联inode的描述符

> 文件描述符fd：
>
> 每个进程PCB结构中有文件描述符指针，指向files_struct的文件描述符表，记录每个进程打开的文件列表。
>
> 系统内核不允许应用程序访问进程的文件描述符表，只返回这些结构的索引即文件描述符ID(File Description)给应用程序
>
> **特殊文件描述符号**：标准输入STDIN_FILENO，标准输出STDOUT_FILENO，标准错误STDERR_FILENO
>
> 每个进程被加载后，默认打开0,1,2这三个文件描述符

open打开文件，就把此文件描述符fd放到进程PCB里的文件描述符表中，close的话就从文件描述表中移走吧..

> 程序开始执行时在0、 1、 2文件描述符上自动打开的文件就是终端

> 在Linux下面一切皆文件， 文件描述符(file descriptor)是内核为文件所创建的索引 ，所有I/O操作都通过调用文件描述符(索引)来执行，包括下面我们要提到的socket。Linux刚启动的时候会自动设置0是标准输入，1是标准输出，2是标准错误。

> 网络 IO 的本质是 socket 的读取，socket 在 linux 系统被抽象为流，IO 可以理解为对流的操作。刚才说了，对于一次 IO 访问 (以 read 举例)，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。





普通磁盘数据文件与设备文件映射时inode往后路径就分叉了，前者去调用相关函数操作磁盘，后者去调用相关函数去操作其它设备，无论哪种文件，对用户而言都是字符流

比如 cat /proc/psinfo 中proc文件显然不在磁盘上

cat中就是read+printf

存在于 /dev 目录中的设备文件怎么去理解？？？

像网卡这种，网络交互的数据也是数据对吧，只是不存储于磁盘而已嘛。

> 设备文件并不真正存储指向的数据，只存储了类型和参数信息

> - 在Linux下“一切皆是文件”！不仅普通的文件，目录、字符设备、块设备、套接字等在unix/linux中都是以文件被对待；他们虽然类型不同，但是对其提供的却是同一套操作界面。

> 这些设备中，有些设备是对实际存在的物理硬件的抽象，而有些设备则是内核自身提供的功能（不依赖于特定的物理硬件，又称“虚拟设备”）。每个设备在 **/dev** 目录下都有一个对应的文件（节点）。

> 设备文件是用来代表物理设备的。**多数物理设备是用来进行输出或输入的**，所以必须由某种机制使得内核中的设备驱动从进程中得到输出送给设备。这可以通过打开输出设备文件并且写入做到，就象写入一个普通文件

> Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：
>
> 系统找到这个文件名对应的inode号码
> 通过inode号码，获取inode信息
> 根据inode信息，找到文件数据所在的block，读出数据。

> Linux下的设备通常分为三类，字符设备，块设备和网络设备。
>
> 见的字符设备有鼠标、键盘、串口、控制台等。
>
> 常见的块设备有各种硬盘、flash磁盘、RAM磁盘等。
>
> 在Linux里一个网络设备也可以叫做一个网络接口，如eth0，应用程序是通过Socket而不是设备节点来访问网络设备，在系统里根本就不存在网络设备节点。
>
> 网络接口没有像字符设备和块设备一样的设备号，只有一个唯一的名字，如eth0、eth1等，而这个名字也不需要与设备文件节点对应

```
+----------------------------------------------------------------+
|                                                                |
|  +--------------------+      +--------------------+            |
|  | User Application A |      | User Application B |<-----+     |
|  +--------------------+      +--------------------+      |     |
|               | 1                    | 5                 |     |
|...............|......................|...................|.....|
|               ↓                      ↓                   |     |
|         +----------+           +----------+              |     |
|         | socket A |           | socket B |              |     |
|         +----------+           +----------+              |     |
|                 | 2               | 6                    |     |
|.................|.................|......................|.....|
|                 ↓                 ↓                      |     |
|             +------------------------+                 4 |     |
|             | Newwork Protocol Stack |                   |     |
|             +------------------------+                   |     |
|                | 7                 | 3                   |     |
|................|...................|.....................|.....|
|                ↓                   ↓                     |     |
|        +----------------+    +----------------+          |     |
|        |      eth0      |    |      tun0      |          |     |
|        +----------------+    +----------------+          |     |
|    10.32.0.11  |                   |   192.168.3.11      |     |
|                | 8                 +---------------------+     |
|                |                                               |
+----------------|-----------------------------------------------+
                 ↓
         Physical Network

```

> 在Linux中对目录和设备的操作都等同于文件的操作，Linux中文件主要分为4种：普通文件、目录文件、链接文件和设备文件。
>
>    内核通过文件描述符来区分和引用特定的文件。对Linux而言，所有设备和文件的操作都是使用文件描述符来进行的。文件描述符是一个非负的整数，它是一个索引值，并指向在内核中每个进程打开文件的记录表。当打开一个现存文件或创建一个新文件时，内核就向进程返回一个文件描述符；当需要读写文件时，也需要把文件描述符作为参数传递给相应的函数。
>
>    通常，一个进程启动时都会打开三个文件：标准输入、标准输出和出错处理。这三个文件分别对应文件描述法为0、1和2（也就是替换宏STDIN_FILENO、STDOUT_FILEON和STDERR_FILENO）。

> 普通文件：存储普通数据，一般就是字符串。 
> 目录文件：存储了一张表，该表就是该目录文件下，所有文件名和inode的映射关系。 

> 软连接与windows下的快捷方式类似
>
> 软连接就是产生一个新文件(这个文件内容,实际上就是记当要链接原文件路径的信息)，这个文件指向另一个文件的位置

普通文件就是存储在硬盘上的各种常规意义上的文件，目录文件如上，链接文件就是软连接文件，这个设备文件呢，具体分块设备文件，它指硬盘自身，字符设备文件就是键盘鼠标等，而网络设备就是网卡，此外还有管道文件，inode指向内存内核缓冲区？用于实现IPC父子间的通信。

## 31 File System 20210414

最后一层抽象（第四层抽象）：整个磁盘变成一个目录树，是一种分治算法策略

磁盘文件：建立了字符流到盘块集合的映射

根据路径名，得到文件的FCB，即inode

 目录树这个结构自身也放在磁盘上，所以磁盘拔下来插到另一个操作系统中，就直接可以用了

## 32 Directory Resolution 20210414

write和read要去利用fd去操作

而open就是怎样去找到文件的inode，然后建立一个fd来和inode连接，反出去。