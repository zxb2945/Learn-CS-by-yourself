# 交换机芯片驱动开发

# Ethernet for Switch 2024.6

| 名词     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| BCM88680 | 博通公司（Broadcom）生产的一款高性能网络处理器芯片，属于Broadcom's Jericho2系列。它用于构建高端路由器、交换机和其他网络设备，支持多种网络协议，包括IPv4、IPv6、MPLS等。 |
| RFC2544  | 由 IETF (Internet Engineering Task Force) 定义的一套用于测试和评估网络设备性能的标准。它提供了一系列测试方法，主要用于评估以太网设备的性能。这些测试包括吞吐量、延迟、帧丢失率、背靠背帧测试和系统恢复测试。 |
|          |                                                              |
|          |                                                              |
|          |                                                              |
|          |                                                              |
|          |                                                              |
|          |                                                              |
|          |                                                              |



## Ethernet基本格式

标准以太网数据帧示例：

```
+-------------------------+-------------------------+-------------------------+
| Destination MAC Address | Source MAC Address      | Ethernet Type           |
+-------------------------+-------------------------+-------------------------+
| 6 bytes                 | 6 bytes                 | 2 bytes                 |
+-------------------------+-------------------------+-------------------------+
|                              Payload/Data                                  |
+-------------------------------------------------------------------------+
|                           46-1500 bytes                                  |
+-------------------------------------------------------------------------+
|                               CRC (4 bytes)                              |
+-------------------------------------------------------------------------+
```

标准以太网帧的数据字段最小为46字节，最大为1500字节。加上其他字段，整个帧的长度为：

- 最小帧长度：46 + 18 = 64字节
- 最大帧长度：1500 + 18 = 1518字节

=>以太网的MTU是1500



802.3与EthII的区别：

IEEE 802.3是以太网的标准化规范，而Ethernet II则是早期在以太网发展中使用的一种帧格式。

=>两者的区别主要在于 对 Ethernet Type的解释有差异。在IEEE 802.3中，如果长度字段的值小于等于1500（0x05DC），则被解释为帧长度；如果大于这个值，则被解释为帧类型。Ethernet II只解释为帧类型，比如IPv4（0x0800）、ARP（0x0806）等。

随着技术的进步，现代以太网通常更多地遵循IEEE 802.3标准，但Ethernet II仍然在某些特定的应用场景中得到使用和支持。



## VLAN

VLAN：

VLAN（Virtual Local Area Network）是一种逻辑上的网络划分技术。实现通过在以太网帧的头部添加额外的VLAN标签（即802.1Q标签）,这个标签的存在使得交换机能够识别和处理不同的VLAN，并且在不同的VLAN之间进行隔离和通信。

引入VLAN概念后，数据帧只在相应的VLAN进行交换。用通俗一点的话来讲，一个交换机被虚拟出了多个逻辑交换机，每一个VLAN内的端口都是一个逻辑上的交换机。

带VLAN标记的以太网数据帧结构（IEEE 802.1Q）:

```
+-------------------------+-------------------------+-------------------------+
| Destination MAC Address (6 bytes) | Source MAC Address (6 bytes) | TPID (2 bytes, 0x8100) |
+-------------------------+-------------------------+-------------------------+
| TCI (2 bytes)           | Ethernet Type (2 bytes) |
+-------------------------+-------------------------+
|                          Payload/Data (46-1500 bytes)                          |
+-------------------------------------------------------------------------+
|                               CRC (4 bytes)                              |
+-------------------------------------------------------------------------+

```

> **TPID (0x8100)**：表示这是一个带有VLAN标签的以太网帧。
>
> **TCI**：包含VLAN ID和优先级信息。
>
> **Ethernet Type**：指示上层协议类型，例如IPv4（0x0800）或IPv6（0x86DD）。

=>VLAN标签就是在Ethernet Type之前插入由TPID (0x8100)+TCI组成的四字节长的标签，增加VLAN标签后，以太帧最大长度会增加4字节到1522字节。

=>VLAN 是二层广播隔离，决定“谁能看到广播”；Subnet 是三层逻辑隔离，决定“谁能访问谁”。两者常常配合使用，VLAN 负责广播控制，Subnet 负责 IP 管理和访问控制。(2025.7.19)

## MPLS

 MPLS位于TCP/IP协议栈中的链路层和网络层之间，MPLS以标签交换替代IP转发。标签是一个短而定长的、只具有本地意义的连接标识符，标签封装在链路层和网络层间。

### L2VPN

MPLS L2VPN数据帧：

```
+-----------------------------------------------------------------------------------------------+
|                      Ethernet Header (14 bytes) + MPLS Header (4 bytes)                        |
+-------------------------+-------------------------+-------------------------+-----------------+
| Destination MAC Address | Source MAC Address      | Ethernet Type (0x8847)  | MPLS Label Stack |
+-------------------------+-------------------------+-------------------------+-----------------+
| 00:11:22:33:44:55       | 66:77:88:99:AA:BB       | 0x8847                  | Label 1          |
|                         |                         |                         | Label 2          |
|                         |                         |                         |                  |
+-------------------------+-------------------------+-------------------------+-----------------+
|                                                                                               |
|                      Ethernet Frame (Payload) (IPv4 + TCP + Application)                      |
|                                                                                               |
+-------------------------+-------------------------+-------------------------+-----------------+
| Destination MAC Address | Source MAC Address      | Ethernet Type (0x0800)  | IPv4 Header      |
+-------------------------+-------------------------+-------------------------+-----------------+
| Destination MAC Address | Source MAC Address      | Ethernet Type (0x0800)  | IPv4 Header      |
|                         |                         |                         | TCP Header       |
|                         |                         |                         | Application Data |
+-------------------------+-------------------------+-------------------------+-----------------+
|                                                                                               |
|                                         CRC (4 bytes)                                        |
|                                                                                               |
+-----------------------------------------------------------------------------------------------+
```

> 目的MAC地址为 `00:11:22:33:44:55`，源MAC地址为 `66:77:88:99:AA:BB`。
>
> Ethernet类型字段为 `0x8847`，表示这是一个MPLS帧。
>
> MPLS标签栈包含了两个标签（Label 1和Label 2），用于指示数据包的转发路径。
>
> MPLS Payload部分是一个完整的以太网帧，包含目的MAC地址、源MAC地址、Ethernet类型字段（0x0800表示IPv4）和IPv4数据包的头部、TCP头部以及应用数据。
>
> CRC字段包含帧的循环冗余校验值，用于帧的错误检测

=>L2VPN包括VPWS与VPLS

其中VPLS有以下功能：

MAC地址学习,MAC地址迁移: 以太网交换原理可以概括为 ‘源MAC学习，目的MAC转发’

FRR保护: （Fast Reroute，快速重路由） 旨在当网络中链路或者节点失效后，为这些重要的节点或链路提供备份保护，实现快速重路由，减少链路或节点失效时对流量的影响，使流量实现快速恢复。

ECMP/LAG

### L3VPN

MPLS L3VPN数据帧：

```
+---------------------------------------------------------------------------------------------------+
|                  Ethernet Header (14 bytes) + MPLS Header (4 bytes)                                 |
+-------------------------+-------------------------+-------------------------+---------------------+
| Destination MAC Address | Source MAC Address      | Ethernet Type (0x8847)  | MPLS Label Stack     |
+-------------------------+-------------------------+-------------------------+---------------------+
| 6 bytes                 | 6 bytes                 | 2 bytes                 | 4 bytes              |
+-------------------------+-------------------------+-------------------------+---------------------+
|                              IPv4 Header (20 bytes)                                                 
+-------------------------+-------------------------+-------------------------+---------------------+
| TCP/UDP Header          | Application Data        | Padding/Options         | CRC (4 bytes)        |
+-------------------------+-------------------------+-------------------------+---------------------+
| Variable length         | Variable length         | Variable length         | 4 bytes              |
+-------------------------+-------------------------+-------------------------+---------------------+

```

=>可以看到L3VPN相对于L2VPN来说，不用包两层以太头了。即便加入了MPLS，以太网帧长度仍不会超过1518字节。



## 各式报文

### ARP报文

ARP（Address Resolution Protocol，地址解析协议）报文用于将IP地址解析为MAC地址。

```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Destination MAC Address (6 bytes)                                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Source MAC Address (6 bytes)                                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Ethernet Type (2 bytes) = ARP (0x0806)                                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| ARP Message                                                               |
| (28 to 46 bytes)                                                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

> 1. **Ethernet Type**：以太网类型字段，2字节，表示数据帧中的上层协议类型。对于ARP消息，以太网类型为0x0806，表示后续数据是ARP协议的数据部分。
> 2. **ARP Message**：ARP消息的内容部分，包括以下字段：
>    - **Hardware Type**：硬件类型，2字节。
>    - **Protocol Type**：协议类型，2字节。
>    - **Hardware Addr Len**：硬件地址长度，1字节。
>    - **Protocol Addr Len**：协议地址长度，1字节。
>    - **Opcode**：操作码，2字节，指示ARP报文的类型。
>    - **Sender MAC Address**：发送ARP请求或应答的设备的MAC地址，6字节。
>    - **Sender IP Address**：发送ARP请求或应答的设备的IP地址，4字节。
>    - **Target MAC Address**：目标MAC地址，在ARP请求中通常为全0，在ARP应答中为目标设备的MAC地址，6字节。
>    - **Target IP Address**：目标IP地址，ARP请求或应答中的目标设备的IP地址，4字节。
>
> ARP消息被封装在以太网帧中，以太网帧的头部包含了目的MAC地址、源MAC地址和以太网类型字段，而ARP消息本身作为以太网帧的数据部分。这种封装方式使得ARP消息能够在以太网中进行传输和处理，从而实现IP地址到MAC地址的解析和映射。

### ICMP报文

ICMP（Internet Control Message Protocol，互联网控制报文协议）是一种网络层协议，用于在IP网络中传递控制消息。常见的ICMP报文类型包括“回显请求”和“回显应答”，也就是通常所说的ping操作。

IPv4数据报格式：

以太网类型：指示上层协议类型为IPv4（0x0800）

```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version (4 bits)|  IHL (4 bits) |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags (3 bits)|      Fragment Offset (13 bits)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum (16 bits)      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source IP Address (4 byte)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination IP Address (4 byte)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    ICMP Message (variable length)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

> 版本（Version）：IPv4版本号。
>
> IHL（Internet Header Length）：IPv4头部长度。
>
> Type of Service：服务类型。
>
> Total Length：整个IPv4数据报的总长度。
>
> Identification、Flags、Fragment Offset：用于分片的字段。
>
> Time to Live：生存时间，用于限制数据报在网络中的生存时间。
>
> Protocol：指示上层协议为ICMP（1）。
>
> Header Checksum：IPv4头部校验和。
>
> Source IP Address：发送ICMP消息的设备的IP地址。
>
> Destination IP Address：目标设备的IP地址。

=>除了ARP报文之外，ICMP,OSPF等均在IPv4协议上传输.

> **最小长度**：IPv4头部的最小长度是20字节，没有数据部分。
>
> **最大长度**：IPv4报文的最大长度是65535字节（2^16 - 1），包括头部和数据部分。
>
> 当IPv4报文的长度超过链路层的MTU时，IP层会将报文分成多个片段，每个片段都包含原始IP头部的副本，并在适当的位置加入分片偏移量。

### OSPF报文

> OSPF（Open Shortest Path First）是一种用于内部网关协议（IGP）的链路状态路由协议，用于在路由器之间交换路由信息。
>
> OSPF报文主要有5种：Hello报文、DD （Database Description，数据库描述）报文、LSR （LinkState Request，链路状态请求）报文、LSU（LinkState Update，链路状态更新）报文和LSAck（LinkState Acknowledgment，链路状态应答）报文。它们各自在OSPF路由更新中所担当的用途不一样，报文格式也存在比较大的差别。

### RSVP报文

> RSVP（Resource Reservation Protocol）是一种用于实时流量管理和服务质量（QoS）保证的网络协议。它允许网络设备（如路由器）在网络路径上设置资源预约，以确保能够满足特定流量的带宽、延迟、抖动等需求。RSVP通过控制消息来协商和建立这些资源预约。

### IGMP报文

> IGMP（Internet Group Management Protocol）是一种用于管理多播组成员的协议。它在IPv4网络中允许主机向路由器报告其多播组成员身份。

## 补充：驱动开发

> 内核模式驱动（Kernel Mode Driver）和用户模式驱动（User Mode Driver）是操作系统中的两种驱动程序，它们在运行环境、权限、性能、安全性等方面存在显著的区别。

=>内核模式驱动 高风险高性能开发复杂 如网络适配器、硬盘控制器驱动、GPU驱动等。用户模式驱动, 如打印机驱动、USB设备驱动、音频设备驱动等。

> **内核模式驱动**通常用于需要直接访问硬件资源、需要高性能和低延迟的设备，如网络适配器、硬盘控制器和GPU。这些驱动程序运行在内核空间，具有高权限和直接硬件访问能力，但也因此带来更高的风险和开发复杂性。
>
> **用户模式驱动**通常用于对性能要求不高、需要较高安全性和稳定性的设备，如打印机、USB设备和某些音频设备。这些驱动程序运行在用户空间，权限受限，开发和调试相对简单，更安全且不易导致系统崩溃。

> **内核模式驱动**通常有以下两种编译: 内核模块通常作为独立的模块编译，不需要与内核一起编译。它们可以在需要时加载或卸载，而无需重启系统。内核模块编译生成 `.ko` 文件，可以通过 `insmod` 或 `modprobe` 命令动态加载到内核中。
>
> 某些驱动程序可能需要与内核一起编译，成为内核的一部分。这通常是出于需要在启动时立即可用或对性能有特殊要求的考虑。核内置驱动程序会与内核一起编译和链接，生成的内核映像包含这些驱动程序。这需要重新编译内核并重启系统以生效。
>
> **用户模式驱动**则不需要与内核一起编译，它们作为普通的用户空间程序编译和运行：用户模式驱动通常使用常规的用户空间编译工具（如 `gcc`）进行编译。用户模式驱动以可执行文件或库的形式存在，通常与应用程序一起部署，可以通过普通的用户空间方式加载和运行。
>
> ### 总结
>
> - **内核模式驱动**可以作为内核模块独立编译和动态加载，不需要与内核一起编译；但某些情况下（如启动时需要加载）也可以选择与内核一起编译。
> - **用户模式驱动**完全在用户空间运行，不需要与内核一起编译，通过普通的编译和部署方式进行操作。



# CCNA

Cisco Certified Network Associate (CCNA)

参考书籍：CCNA 200-301 Official Cert Guide, Volume 1 Premium Edition eBook and Practice Test (Wendell Odom) (Z-Library)

## Introduction to Networking

### 1  Introduction to TCP/IP Networking 2024.7.2

TCP/IP Networking Model

**Open Systems Interconnection** (OSI) networking model

To define a protocol, TCP/IP uses documents called **Requests For Comments (**RFC). the Institute of Electrical and Electronic Engineers (IEEE) defines Ethernet LANs; the TCP/IP model does not define Ethernet in RFCs, but refers to IEEE Ethernet as an option.

HTTP Overview

TCP/IP Network Layer

=>对于2，3，4层都是Encapsulation, 对物理层是Transimit the bits.

Perspectives on Encapsulation and “Data”: Frame, Packet, Segment(TCP Header + data)

=>TCP/IP Networking Model跟OSI某种程度上是两种Model，最后是前者win that battle. 主要区别就是前者5-7层合并了.

Today, the OSI model can be used as a standard of comparison to other networking models. OSI uses a more generic term to refer to messages, rather than frame, packet, and segment.OSI uses the term **protocol data unit** (PDU).

=>  Frame == L2PDU

### 2 Fundamentals of Ethernet LANs 2024.7.3

Today, Ethernet includes many standards for different kinds of optical and copper cabling, and for speeds from 10 megabits per second (Mbps) up to 400 gigabits per second (Gbps).

=>以太网即可用光纤，也可以用铜缆。但跟wireless无关，可以达到10 Gbps（5G实测最高可以超过1Gbps）

Unshielded Twisted Pair (UTP) cabling. =>双绞线



Table IEEE 802.3 Ethernet Header and Trailer Fields

| Field                       | Bytes   | Description                                                  |
| --------------------------- | ------- | ------------------------------------------------------------ |
| Preamble                    | 7       | Synchronization sequence before the start of the frame.      |
| Start Frame Delimiter (SFD) | 1       | Indicates the beginning of the Destination MAC Address field. |
| Destination MAC Address     | 6       | Identifies the intended recipient of the frame.              |
| Source MAC Address          | 6       | Identifies the sender of the frame.                          |
| Type                        | 2       | Specifies the protocol encapsulated within the frame (e.g., IPv4 or IPv6). |
| Data and Pad                | 46-1500 | Contains payload data from a higher layer (usually IPv4 or IPv6 packets) with optional padding to meet a minimum length requirement. |
| Frame Check Sequence (FCS)  | 4       | Provides error checking for the frame to detect transmission errors. |

1500 bytes is the largest IP MTU allowed over an Ethernet.

### 3 Fundamentals of WANs and IP Routing 2024.7.5

Because leased lines define only the Layer 1 transmission service, many companies and standards organizations have created data-link protocols to control and use leased lines. Today, the two most popular data-link layer protocols used for leased lines between two routers are **High-Level Data Link Control** (HDLC) and Point-to-Point Protocol (PPP).

=>HDLC适用于点对点的位于WAN中的路由器之间通信，而以太网更适合用于易于广播的LAN. 

=>也就是说传统的WAN中并不是不使用链路层，而是不使用以太网作为链路层。

As time went by, and as the IEEE improved cabling distances for fiber Ethernet links, Ethernet became a reasonable WAN technology.

=>就是有人想在WAN上用以太网协议，就发明了EoMPLS(Ethernet over MPLS) :  Ethernet LAN <=> EoMPLS WAN <=> Ethernet LAN

EoMPLS允许以太网数据通过MPLS网络进行封装和传输。这使得以太网的广播和多播特性得以在跨越不同地理位置的网络中保持。

=>虽然在WAN上主要还是点对点传播，但MPLS包裹住了以太头信息，以至于VPN中可以进行广播操作



Because the routers build new data-link headers and trailers, and because the new headers contain data-link addresses, the PCs and routers must have some way to decide what datalink addresses to use.

For example, Router R3 would use ARP once to learn PC2’s MAC address before sending any packets to PC2.

=>一个路由器保存一个路由表，路由表上不仅有IP信息，还有发往这个路由包以太头还是HDLC的信息。

=>IPv4 Header总共20字节，其中最后8字节分配给 Source IP Addr + Dest IP Addr

```
//IPv4 Header, Organized as 4 Bytes Wide for a Total of 20 Bytes
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version (4 bits)|  IHL (4 bits) |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags (3 bits)|      Fragment Offset (13 bits)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum (16 bits)      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source IP Address (4 byte)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination IP Address (4 byte)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```



These last three topics just help fill in a few holes, helping to give you some perspective and helping you make sense of later discussions as well. The three topics are
■ Domain Name System (DNS)
■ Address Resolution Protocol (ARP)
■ Ping

=>自己目前为止的知识面还是可以的，以上三点都能cover



## Implementing Ethernet LANs

### 4 Using the Command-Line Interface 2024.7.8

Accessing the CLI with Telnet and SSH

=>对Cisico 设备简单的登录等操作命令的说明

### 5 Analyzing Ethernet LAN Switching

> 在网络通信中，Preamble（前导码）通常不被计算为以太网帧的有效载荷部分，因为它是用于同步和定时的特殊数据序列，并不包含在帧的实际数据部分中。

A switch’s MAC address table is also called the switching table, or bridging table

the port as listed in the MAC table entry for that MAC address.

unicast => 单播

Learning MAC Addresses：对于Switch而言，报文从某个口发送进来，解析其SMAC，将port与SMAC(可以作为其他报文的DMAC)写入MAC表

Switch Flooding: Unknown Unicast and Broadcast Frames(address of FFFF.FFFF.FFFF)) =>未知单播报文洪泛

The result of STP is good: frames do not loop infinitely =>  Spanning Tree Protocol (**STP**) 是一种网络协议，用于在有冗余路径的网络中防止环路

> 不同的交换机厂商和设备可能对未知单播报文的处理方式有所不同。有些设备可能默认选择洪泛，而有些设备可能默认选择丢弃。洪泛未知单播报文可能导致网络中的广播风暴（Broadcast Storm），影响网络性能

LAN switches forward Ethernet frames inside a VLAN. What that means is if a frame enters via a port in VLAN 1, then the switch will forward or flood that frame out other ports in VLAN 1 only, and not out any ports that happen to be assigned to another VLAN.

=>VLAN信息也存在于MAC表中，frame只在同一个VLAN中传播

Managing the MAC Address Table (Aging, Clearing): First, for aging out MAC table entries, switches remove entries that have not been used for a
defined number of seconds (default of 300 seconds on many switches).

### 6 Configuring Basic Switch Management 2024.7.10

To allow Telnet or SSH access to the switch, and to allow other IP-based management protocols(for example, Simple Network Management Protocol, or SNMP) to function as intended, the switch needs an IP address, as well as a few other related settings. The IP address has nothing to do with how switches forward Ethernet frames; it simply exists to support overhead management traffic.

=>how to configure the switch to support Telnet and Secure Shell (SSH) by configuring IP address and login security. 配置IPv4，用于使用SSH，Telnet远程登陆Cisco switches.

The switch can also use Dynamic Host Configuration Protocol (DHCP) to dynamically learn its IPv4 settings. 

### 7 Configuring and Verifying Switch Interfaces

IOS uses the term interface to refer to **physical ports** used to forward data to and from other devices.

Configuring Speed, Duplex, and Description



## Implementing VLANs ans STP

### 8 Implementing Ethernet Virtual LANs

=>VLAN用于给物理上的LAN划分更小单位的逻辑LAN, 所以VLAN不是VPN，它是用来逻辑划分物理局域网的，而MPLS可以用在VPN上

When you are using VLANs in networks that have multiple interconnected switches, the switches need to use VLAN trunking on the links between the switches. VLAN trunking causes the switches to use a process called VLAN tagging, by which the sending switch adds another header to the frame before sending it over the trunk. This extra trunking header includes a VLAN identifier (VLAN ID) field so that the sending switch can associate the frame with a particular VLAN ID, and the receiving switch can then know in what VLAN each frame belongs.

=>交换机的VLAN trunking功能用于给帧加额外的VLAN标签

=>交换机尽管有自己的MAC地址，但不会去更改收到的以太帧中的SMAC吧.

The use of trunking allows switches to forward frames from multiple VLANs over a single physical connection by adding a small header to the Ethernet frame.

=>一个物理口可以转发多个VLAN，所以被称为Trunk吧 => 交换机的一个物理端口可以绑定多个VLAN，这个功能通常称为“干线（trunking）

Creating VLANs and Assigning Access VLANs to an Interface. For a Cisco switch to forward frames in a particular VLAN, the switch must be configured
to believe that the VLAN exists. In addition, the switch must have nontrunking interfaces(called access interfaces, or static access interfaces) assigned to the VLAN

=>所以Trunking interface 与 Access  interface是两个对立的概念。是不是可以这样理解，后者给以太帧填VLAN标签，而前者仅对即存VLAN标签转发，所以可以绑定多个VLANs.

> 交换机在接收到数据帧时，首先会检查数据帧是否带有 VLAN 标签。如果有标签，交换机会根据标签决定数据帧所属的 VLAN。如果没有标签，则交换机会根据接收端口的配置来决定数据帧的 VLAN 归属（即Access  VLAN）。如果交换机端口配置为接入模式（Access Mode），则该端口只能传输属于单一 VLAN 的数据。

802.1Q inserts an **extra** 4-byte 802.1Q VLAN header into the original frame’s Ethernet header

=>导致以太帧 从 1518 byte 增大到 1522 bytes

Dest Address +  Source Address + **VLAN Tag**  + Type +  Data + FCS

子网与VLAN的区别：

> Subnets（子网）是对IP地址空间的划分，用于将一个大的IP网络划分成多个较小的逻辑网络单元。每个子网都有一个特定的IP地址范围，并且通常由子网掩码来定义。子网内的设备可以直接进行通信，而跨越不同子网的通信需要通过路由器进行。
>
> VLAN是一种在物理网络基础设施上实现的逻辑网络分割技术，允许将单个物理网络划分成多个逻辑上独立的虚拟局域网。VLAN通过在交换机上配置不同的VLAN标识（通常是802.1Q标准的标签），来区分不同的逻辑网络。同一物理网络上的设备可以被划分到不同的VLAN中，从而在逻辑上隔离它们的数据流量。
>
> 子网是在网络层（第三层）上划分IP地址空间，VLAN是在数据链路层（第二层）上实现的逻辑网络划分。

L2 Switch 与 L3 Switch的区别：

> 二层交换机主要在数据链路层（第二层）上操作，基于MAC地址来转发数据帧。
>
> 三层交换机在数据链路层（第二层）和网络层（第三层）上操作，除了基于MAC地址进行数据帧转发外，还能进行基于IP地址的数据包路由转发。
>
> 二层交换机只能在同一VLAN内进行通信，而三层交换机可以跨VLAN进行路由转发。二层交换机适用于简单的局域网交换；三层交换机适用于复杂的企业网络和服务提供商网络，需要路由功能和高级的网络管理。

### 9 Spanning Tree Protocol Concepts 2024.7.16

STP/RSTP prevents three common problems in Ethernet LANs. All three problems occur as a side effect of one fact: without STP/RSTP, some Ethernet frames would loop around the network for a long time

> Spanning Tree Protocol (STP) 是一种用于计算并维护以太网网络中无环的拓扑结构的网络协议。它的主要作用包括：
>
> 环路消除；冗余路径选择；自动网络重构；广播风暴抑制

Most modern networks use RSTP instead of STP.

> RSTP（Rapid Spanning Tree Protocol）是STP（Spanning Tree Protocol）的改进版本，旨在提供更快的收敛时间和更好的性能。

=>这一章对STP机制的讲解还是很深入的，我只是glance一眼，了解STP主要用于防止loop就行

### 10 RSTP and EtherChannel  Configuration

## IPv4 Addressing

### 11 Perspectives on IPv4 Subnetting 2024.7.17

=>Subnet用于分割私有IP网段.Class A B C根据不同的私有IP网段来分的

To make routing work efficiently, IP addressing rules group addresses into groups called subnets.
The rules are as follows:
■ Addresses in the same subnet are not separated by a router.
■ Addresses in different subnets are separated by at least one router.

=>VLAN是基于Layer2, Subnet是基于Layer3

=>为解决IPv4耗尽的问题，提出了几个solution：

■ A new version of IP (IPv6), with much larger addresses (128 bit)
■ Assigning a subset of a public IP network to each company, instead of an entire public IP network, to reduce waste, using a feature called “Classless Interdomain Routing” (CIDR)
■ Network Address Translation (NAT), which allows the use of private IP networks

=>其中一个就是分配专有网段用于私网IP，从而实现唯一公网IPx众多私网IP；另一个方案就是引入IPv6

> 通常情况下，不同设备经过NAT后分配到的端口号是不同的。这是因为NAT设备在进行地址转换时会确保每个设备使用的端口号是唯一的，以避免冲突和混淆。

=>NAT服务器转换私有IP到公有IP的过程中，虽然公有IP也许只有一个，但是可以给不同设备分配不同的发送端口来区分

> 通过不同的子网掩码，同一个IP地址的网络部分的定义可以有所不同，因此可以属于不同的子网。这种灵活性使得网络管理员可以根据网络规模和需求来划分和管理IP地址空间。

However, the subnet’s size is not 2H. It’s 2H – 2 because two numbers in each subnet are reserved for other purposes. Each subnet reserves the numerically lowest value for the **subnet number** and the numerically highest value as the **subnet broadcast address**. As a result, the number of usable IP addresses per subnet is 2H – 2.

> 子网（subnet）在计算机网络中的作用主要包括以下几个方面：地址管理和划分 减少广播域 增强网络安全性 提高网络效率 支持多种网络服务

=>划分子网的时候，只能选取一个固定的Mask，因此所有子网的network part长度是一样的 => Use a single mask for all subnets.



### 12 Analyzing Classful IPv4 Networks 2024.7.23

A Network (8) Host (24)   Default mask:255.0.0.0

B Network (16) Host (16)  Default mask:255.255.0.0

C Network (24) Host (8)  Default mask:255.255.255.0

=>Class A,B,C 有Default Masks来确定的Sizes. 所以A Network相对于C Network就更适用于更大的网络



IPv4 Address Classes Based on First Octet Values

| Class | First Octet Values | Purpose                          |
| ----- | ------------------ | -------------------------------- |
| A     | 1–126              | Unicast (large networks)         |
| B     | 128–191            | Unicast (medium-sized networks)  |
| C     | 192–223            | Unicast (small networks)         |
| D     | 224–239            | Multicast                        |
| E     | 240–255            | Reserved (formerly experimental) |

=>**不要把Class ABC的分类局限于 Private Network！！！后者只是在Class ABC选了一个微小的网段！**

> **IPv4 私有地址范围**：
>
> - **10.0.0.0 - 10.255.255.255**（/8 子网掩码）
> - **172.16.0.0 - 172.31.255.255**（/12 子网掩码）
> - **192.168.0.0 - 192.168.255.255**（/16 子网掩码）

What would be Class A network 127.0.0.0 is still reserved because of a special address used in software testing, called the loopback address (127.0.0.1).



分析步骤：

Step 1. Determine the class (A, B, or C) based on the first octet.
Step 2. Mentally divide the network and host octets based on the class.
Step 3. To find the network number, change the IP address’s host octets to 0.
Step 4. To find the first address, add 1 to the fourth octet of the network ID.
Step 5. To find the broadcast address, change the network ID’s host octets to 255.
Step 6. To find the last address, subtract 1 from the fourth octet of the network broadcast address.



### 13 Analyzing Subnet Masks

Example Conversions: Prefix to Binary  =>Prefix (also called classless interdomain routing [**CIDR**])

Converting Between Prefix and DDN Masks

| Prefix Mask | Logic                            | Binary Mask                         |
| ----------- | -------------------------------- | ----------------------------------- |
| /28         | Write 28 1s, then 4 0s, total 32 | 11111111 11111111 11111111 11110000 |



By definition, a dotted-decimal number (DDN) used with IPv4 addressing contains four decimal numbers, separated by dots. **Each decimal number represents 8 bits**. So, a single DDN shows four decimal numbers that together represent some **32-bit binary number**.

=>/28 怎么看？ 是从头到尾 覆盖多少bit 1，一个IP每位就是8bit，总共32位！

=>用了CIDR，就不搞Class ABC 这个Classful Addressing这一套了

### 14 Analyzing Existing Subnets 2024.7.25

> 假设有一个 Class C 网络，IP 地址为 192.168.1.0，子网掩码为 255.255.255.0（/24）。
>
> - **Network ID** 是 192.168.1.0。
> - 如果将该网络划分为多个子网，每个子网有不同的子网标识符（Subnet ID），例如：
>   - 子网 A 的子网标识符（Subnet ID）可能是 192.168.1.0/26（子网掩码为 255.255.255.192）中的第一个地址，即 192.168.1.0。
>   - 子网 B 的子网标识符（Subnet ID）可能是 192.168.1.64/26 中的第一个地址，即 192.168.1.64。

> IP地址 192.168.1.0/26 是一个CIDR（Classless Inter-Domain Routing，无类域间路由）表示法表示的IP地址和子网掩码的组合长度
>
> 子网标识符（Subnet ID）可以理解为网络标识符（Network ID）的一种特例。在网络术语中，这两个术语通常可以互换使用，尤其是在讨论子网划分时。

=>CIDR == Network ID/子网的掩码 ,搞半天子网什么概念的，就是摈弃经典划分，自由地划分网络啦，子网ID某种程度上就是Network ID嘛.

=>也许在classful addressing rules情况下，Network ID与Subnet ID有区别，前者毕竟按Class A B C固定的嘛，而后者根据CIDR灵活选择

=>这两张就是根据CIDR二进位各种计算Network ID和广播地址...脑袋大了

## IPv4 Routing

### 15 Operating Cisco Routers

=>介绍了一些Cisco Routers的命令

### 16 Configuring IPv4 Addresses and Static Routes 2024.7.26

IP routing—the process of forwarding IP packets—delivers packets across entire TCP/IP networks



Step 1. If the destination is local, send directly

Step 2. If the destination is not local, send to the default gateway



Routing Step 1: Decide Whether to Process the Incoming Frame

Routing Step 2: De-encapsulation of the IP Packet

Routing Step 3: Choosing Where to Forward the Packet

Routing Step 4: Encapsulating the Packet in a New Frame

Routing Step 5: Transmitting the Frame



The IPv4 ARP table lists the IPv4 address and matching MAC address of hosts connected to the same subnet as the router.

### 17 IP Routing in the LAN

Ethernet defines the concept of a VLAN, while IP defines the concept of an IP subnet, so a VLAN is not equivalent to a subnet. However, the set of devices in one VLAN are typically also in one subnet. By the same reasoning, devices in two different VLANs are normally in two different subnets.

A Layer 3 switch (also called a multilayer switch) is one device, but it executes logic at two layers: Layer 2 LAN switching and Layer 3 IP routing. The Layer 2 switch function forwards frames inside each VLAN, but it will not forward frames between VLANs. The Layer 3 forwarding (routing) logic forwards IP packets between VLANs.

### 18 Troubleshooting IPv4 Routing

Problem Isolation Using the ping Command

More formally, the ping command uses the Internet Control Message Protocol (ICMP), specifically the ICMP echo request and ICMP echo reply messages. ICMP defines many other messages as well, but these two messages were made specifically for connectivity testing by commands like ping. As a protocol, ICMP does not rely on TCP or UDP, and it does not use any application layer protocol.



Problem Isolation Using the traceroute Command

Like ping, the traceroute command helps network engineers isolate problems.

> `traceroute` 是一个网络诊断工具，用于跟踪数据包在从你计算机到目标主机之间的路径。它可以帮助你查看网络路径上的每一跳，并且诊断网络延迟或连接问题。

```
C:\Users\exzihon>tracert -d www.google.com

Tracing route to www.google.com [142.250.199.100]
over a maximum of 30 hops:

  1     2 ms     2 ms     1 ms  172.20.10.1
  2     *        *        *     Request timed out.
  3     *        *        *     Request timed out.
  4    25 ms    37 ms    37 ms  126.211.185.18
  5    32 ms    49 ms    25 ms  126.211.185.36
  6    55 ms    41 ms    34 ms  126.211.185.41
  7    66 ms    50 ms    41 ms  221.110.37.177
  8     *        *        *     Request timed out.
  9     *        *        *     Request timed out.
 10    65 ms    28 ms    38 ms  72.14.214.193
 11    42 ms    35 ms    42 ms  192.178.108.217
 12    43 ms    27 ms    45 ms  192.178.108.242
 13     *        *       86 ms  142.250.58.21
 14    54 ms    37 ms    48 ms  209.85.244.3
 15    71 ms    42 ms    47 ms  108.170.248.189
 16    88 ms    42 ms    56 ms  142.250.214.149
 17    51 ms    38 ms    31 ms  142.250.199.100

Trace complete.
```

=>17跳以内找到谷歌服务器？

Both the ping and traceroute commands exist on most operating systems, including Cisco IOS. However, some operating systems use a slightly different syntax for traceroute. For example, most Windows operating systems support **tracert** and pathping, and not traceroute. Linux and OS X support the traceroute command.



Telnet and SSH

Once you begin to get an idea of the kinds of problems and the possible locations of the problems using ping and traceroute, the next step is to look at the status of various router and switch features. One way to do that is to use Telnet or Secure Shell (SSH) to log in to the devices.

=>这一章介绍的东西比较实用，确实是NTC的时候排查问题常用的命令

## OSPF

### 19 Understanding OSPF Concepts 2024.7.29

OSPF runs on each router, sending and receiving OSPF messages with neighboring (nearby) routers.

Border Gateway Protocol (BGP)

> Border Gateway Protocol (BGP) 是一种用于在不同自治系统（AS）之间交换路由信息的协议。自治系统可以是一个大型企业、互联网服务提供商（ISP）或任何其他网络实体，它们需要与其他网络进行路由信息的交换。
>
> BGP是外部网关协议 (EGP)。OSPF是内部网关协议 (IGP)， 主要用于单一自治系统内的路由选择。适用于企业内部的路由和区域内的动态路由。

IGP Routing Protocol Algorithms：The term routing protocol algorithm simply refers to the logic and processes used by different routing protocols to solve the problem of learning all routes, choosing the best route to each subnet, and converging in reaction to changes in the internetwork.

Link-state protocols—in particular, Open Shortest Path First (OSPF) and Integrated Intermediate System to Intermediate System (IS-IS)—solved the main issues. 

> Intermediate System to Intermediate System (IS-IS) 是一种内部网关协议（IGP），用于在单个自治系统（AS）内部的网络中进行路由。与 OSPF 类似，IS-IS 是一种链路状态协议，用于计算网络中最短路径和更新路由表。

> Routing Information Protocol (RIP) 和 Enhanced Interior Gateway Routing Protocol (EIGRP) 都是用于内部网关协议（IGP）的路由协议，用于在同一自治系统（AS）内部交换路由信息。

=>内部网关协议（IGP）的路由协议种类还挺多的，主要应该是算法不同吧

Applying Dijkstra SPF Math to Find the Best Routes =>Dijkstra 算法是一种经典的图算法，用于计算从单个源节点到图中所有其他节点的最短路径。确实用在网络拓扑中是个很好的实用例子

### 20 Implementing OSPF

OSPFv2 requires only a few configuration commands if you rely on default settings. To use OSPF, all you need to do is enable OSPF on each interface you intend to use in the network, and OSPF uses messages to discover neighbors and learn routes through those neighbors.

=>OSPF协议栈写入思科路由器驱动，网络工程师要知道如何去配置，需要熟悉一些command

### 21 OSPF Network Types and Neighbors

Chapter 20, “Implementing OSPF,” discussed the required and most common optional OSPF configuration settings, along with the many verification commands to show how OSPF works with those settings. This chapter continues with more OSPF implementation topics

## IP Version 6

### 22 Fundamentals of IP Version 6 2024.7.30

The fact that IPv6 uses a different size address field, with some different addressing rules, means that many other protocols and functions change as well. For example, IPv4 routing—in other words, the packet-forwarding process—relies on an understanding of IPv4 addresses. To support IPv6 routing, routers must understand IPv6 addresses and routing. As a result, the migration from IPv4 to IPv6 is much more than changing one protocol (IP), but it impacts many protocols.

### 23 IPv6 Addressing and Subnetting

### 24 Implementing IPv6 Addressing on Routers

On Cisco routers, IPv4 routing is enabled by default, but IPv6 routing is not enabled by default. The solution takes only a single command—ipv6 unicast-routing—which enables IPv6 routing on the router.

### 25 Implementing IPv6 Routing

## Wireless LANs

### 26 Fundamentals of Wireless Networks 2024.8.1

Wireless LANs must transmit a signal over radio frequencies (RF) to move data from one device to another.

the **IEEE 802.3** set of standards defines strict guidelines for the Ethernet wire itself, in addition to how devices may connect, send, and receive data over the wire.

Wireless devices must adhere to a common standard (**IEEE 802.11**).

More detailed topics like RF characteristics, antenna performance, and so on are reserved for the Implementing Cisco Enterprise Network Core Technologies ENCOR 300-401 exam.

IEEE 802.11 WLANs are always **half duplex** because transmissions between stations use the same frequency or channel.

=>Ethernet LAN可以用双绞线，所以可以实现fully duplex，WLANS用同一频段的同一信道，所以只能half duplex

Wireless devices must also have unique MAC addresses to send wireless frames at Layer 2 over the air.

=>WLANS的L2仍旧是Ethernet？

Normally, one AP cannot cover the entire area where clients might be located. To cover more area than a single AP’s cell can cover, you simply need to
add more APs and spread them out geographically.

=>所谓的AP相对于提供给无线设备接入LAN的接口，比如无线路由器

If the client later moves to a different location, it can associate with a different nearby AP automatically. Passing from one AP to another is called roaming.

=>RAN本质上跟 WLAN一样

Repeater：Normally, each AP in a wireless network has a wired connection back to the switched infrastructure...

Workgroup Bridge：为之能接入LANs的设备提供无线接入的转化器

Outdoor Bridge: An AP can be configured to act as a bridge to form a single wireless link from one LAN to another over a long distance. Outdoor bridged links are commonly used for connectivity between buildings or between cities.

=>CCNA有点为企业机构 构建 网络解决方案 的意思，这个层面上讲确实跟编程不太相关

Radio Frequency:

Because a range of frequencies might be used for the same purpose, it is customary to refer to the range as a band of frequencies. For example, the range from 530 kHz to around 1710 kHz is used by AM radio stations; therefore, it is commonly called the AM band or the AM broadcast band.

One of the two main frequency ranges used for wireless LAN communication lies between 2.400 and 2.4835 GHz. This is usually called the 2.4-GHz band

The other wireless LAN range is usually called the 5-GHz band because it lies between 5.150 and 5.825 GHz.

just be aware of the two main bands at **2.4 and 5 GHz**.

### 27 Analyzing Cisco Wireless Architectures

Wireless Network Architecture with Autonomous APs

Extent of a Data VLAN in a Network of Autonomous APs

Cloud-based AP Architecture => 一切向云转向

■ A control plane: Traffic used to control, configure, manage, and monitor the AP itself
■ A data plane: End-user traffic passing through the AP

=>control plane与data plane真的是贯穿通信网络的概念

> WLAN中的WLC指的是“Wireless LAN Controller”，即无线局域网控制器。它是用于集中管理和控制无线接入点（AP）的设备。

=>WLC也是思科的一种产品吧，不仅卖路由器交换机

### 28 Securing Wireless Networks

WEP

> WPA 指的是 **Wi-Fi Protected Access**，它是一种无线网络安全协议，旨在增强无线局域网（WLAN）的安全性。WPA 是对早期无线网络协议 WEP（Wired Equivalent Privacy）的改进，提供了更强的加密和认证机制。WPA 的主要目标是保护无线网络免受未经授权的访问和数据窃取。

### 29 Building a Wireless LAN

2.0 Network 
2.7 Describe physical infrastructure connections of WLAN components (AP, WLC,access/trunk ports, and LAG)
2.8 Describe AP and WLC management access connections (Telnet, SSH, HTTP, HTTPS,console, and TACACS+/RADIUS)
2.9 Configure the components of a wireless LAN access for client connectivity using GUIonly, such as WLAN creation, security settings, QoS profiles, and advanced WLAN settings
5.0 Security Fundamentals
5.10 Configure WLAN using WPA2 PSK using the GUI

Accessing a Cisco WLC

Configuring a WLAN

Configuring a WLAN

Configuring WLAN QoS

=>就是讲如何利用类似AWS那样的中央GUI来进行WLAN的配置过程

=>我觉得本书的核心就是讨论如何为客户构建LAN



## 补充：排查网络连通性 2024.8.28

> 诊断一台服务器无法登录的原因可以分为几个步骤，涉及到硬件、网络、操作系统、以及用户权限等方面。以下是一个系统化的步骤指南，帮助你找出问题所在：
>
> ### 1. **检查物理连接和硬件**
>
> - **电源**：确保服务器正常通电。
> - **网络连接**：检查网络线缆是否插好，网络指示灯是否亮起。
> - **硬件状态**：查看服务器的硬件指示灯是否有异常（例如红色指示灯通常表示故障）。
>
> ### 2. **确认网络连接**
>
> - **Ping 测试**：尝试用 `ping` 命令检查服务器是否能够响应。比如：`ping <服务器IP地址>`。
> - **网络配置**：确保服务器的 IP 地址配置正确，没有 IP 冲突。检查网络子网掩码和网关设置是否正确。
> - **防火墙设置**：检查服务器的防火墙是否阻止了远程登录请求。你可以临时禁用防火墙来排除这个因素。
>
> ### 3. **检查远程登录服务**
>
> - **服务状态**：确保远程登录服务（如 SSH 对于 Linux，RDP 对于 Windows）已经启动。你可以通过访问服务器的控制台来检查。
> - **端口监听**：检查服务器是否在监听远程登录端口（例如，SSH 通常使用端口 22，RDP 通常使用端口 3389）。可以使用命令如 `netstat -an | grep <端口号>` 来检查。
>
> ### 4. **检查操作系统**
>
> - **错误信息**：注意登录时出现的错误信息。例如，“密码错误”还是“连接超时”。
> - **系统负载**：高负载可能会导致无法登录。通过服务器的控制台检查系统负载和资源使用情况。
> - **日志文件**：查看系统日志文件，特别是与登录相关的日志，如 `/var/log/auth.log`（Linux）或事件查看器（Windows）。
>
> ### 5. **用户权限和账户**
>
> - **用户账户**：确保你使用的账户具有登录权限。检查账户是否被锁定或禁用。
> - **密码**：确认密码是否正确，并检查是否存在密码过期问题。
>
> ### 6. **其他考虑**
>
> - **安全设置**：有时，服务器可能配置了安全策略或访问控制列表（ACL）来限制登录。如果有权限，检查这些设置是否阻止了你的登录。
> - **系统更新**：最近的系统更新或补丁可能导致登录问题。检查最近的更新记录，并确定是否需要回滚。
>
> ### 7. **恢复访问**
>
> - **单用户模式**（Linux）：在启动过程中进入单用户模式（recovery mode），可以帮助你检查和修复系统问题。
> - **安全模式**（Windows）：尝试以安全模式启动 Windows 系统，以解决可能的驱动程序或服务问题。
>
> ### 总结
>
> 这些步骤可以帮助你系统化地排查服务器无法登录的问题。如果问题复杂，可能需要结合多种方法，或者寻求专业的技术支持。

=>确实是按照OSI模型来，判断物理层，ping， netstat确认端口，再接着检查ACL等设置

# Router 2024.8.2

Router 工具跟DT Tool结构基本一样而且更为简单，输入 诸言文件+一个neid文件，主要输出OAM IP, Gateway IP, subnet, vlan等十个左右关键变量，只输出到一个cfg类型的模板，另外也有Modify部分，加一个BeforeLog输入文件。

```shell
!  Configuration last changed by user '<Precon>' [YYYYMMDD]
!
no service multiple-contexts
!
qos class-map ein-default-dscp-to-dp ip in
 ip 1 to qos 0
 ip 2 to qos 0
 ip 3 to qos 0
 #...
 ip 63 to qos 0
!
global synchronization option 2
!
no release description
!
!release ID 2
!
alarm-port 1 input 1 active low
alarm-port 1 input 1 admin-state disabled
alarm-port 1 input 1 severity critical
#...
no alarm-port 1 input 3 description
!
alarm-port 1 output 1 admin-state disabled
no alarm-port 1 output 1 description
!
netconf tls server admin-state enabled
!
context local
! 
 no ip domain-lookup
!
 interface OSS-Management
  ip address [OAM_IP_Address]/[Subnet]
  ip source-address snmp radius tacacs+ syslog dhcp-server icmp-dest-unreachable 
!
 interface mgmt
  ip address 192.168.88.1/29
!
 ip route 0.0.0.0/0 [OAM_GW_Address]
!
 service ftp client
 service tftp client
 service ssh 
 service sftp 
 service scp 
 service telnet 
 service snmp server

!
 ntp-mode
!
  server [ntpServerAddressPrimary] version 3
  server [ntpServerAddressSecondary] version 3
  server [ntpServerAddressPrimary_BCP] version 3
  server [ntpServerAddressSecondary_BCP] version 3
!
 logging console
!
 aaa authentication administrator local   
!
!
 administrator OSSADM encrypted 2 $abcdefgh
  privilege start 15
  privilege max 15
  role NetconfPlatformAdministrator
  role SudoUser
  role SystemAdministrator
  role TechSupport
  no password-aging
! ** End Context **
!
port ethernet 1/1 10ge 
 description [HostName_#1]
 mtu 9216
 no shutdown
 shutdown
 encapsulation dot1q
 service-instance 101
  match
   dot1q 101
 service-instance 201
  match
   dot1q 201
 service-instance 701
  match
   dot1q 701
!
#...
!
port ethernet 1/28 100ge 
 description [HostName_#28]
 mtu 9216
 no shutdown
 shutdown
 forward-error-correction  auto-config
 link-group LAG_KDDI_ERANSW
 service-instance 101
  match
   dot1q 101
 service-instance 701
  match
   dot1q 701
!
!
port ethernet management 
 no shutdown
 bind interface mgmt local
!
!
port bvi isp-port
 no shutdown
 bridge name GM-BC
   encapsulation dot1q
 dot1q pvc [OAM_vlan]
  bind interface OSS-Management local
!
ipv6 path-mtu-discovery discovery-interval 600
!
service alarm-suppression single-power-feed
!
system hostname [HostName]
system dnprefix SubNetwork=[RootMO],MeContext=[HostName]
!
tcp path-mtu-discovery
!
!
snmp server
 traps ifmib ip
snmp view all internet included
snmp view ENM-View mib_2 included
snmp view ENM-View snmpModules included
snmp view ENM-View ericssonAlarmMIB included
snmp community public all-contexts view ENM-View read-write
snmp target ENM_public_v2c [SnmpTargetV2Caddress] security-name public version 2c view ENM-View 
snmp ericsson-alarm heartbeat-interval 100
bridge 701
 port 1/1 service-instance 701
 port 1/2 service-instance 701
 #...
 port 1/20 service-instance 201
 port 1/24 service-instance 201
!
!
!
!Ethernet connectivity fault management configuration
!
oam instance 1 cfm
 level 7
 domain-name L7_LTE
 maintenance-association icc Area100
  ccm
   std-interval 10s
  mep [OAM_IP_4oct] 1/24 service-instance [OAM_vlan] [OAM_vlan] direction down
  remote-mep [remote_mep]
!
licensing
 fingerprint [fingerprint]
!
LI-START
LI-END
!
synchronization
 ptp-clock g8275-1 t-bc
  acquiring-state announce default-DS
  ptp-port 1
   description Connect to R6672 on native Ethernet
   slave-candidate
   transport ethernet multicast 
    circuit 1/23
   no shutdown 
  #...
  ptp-port 23
   description GM
   slave-candidate
   local-priority 127
   transport ethernet multicast 
    circuit 1/23
   no shutdown 
  ptp-port 24
   description [HostName_#24]
   slave-candidate
   transport ethernet multicast 
    circuit 1/24
   no shutdown 
 equipment-clock
  input-source 1 line 1/23
   priority [priority1]
   priority 102
   priority 202
  input-source 1 line 1/24
   priority [priority1]
  input-source 3 line 1/21
   priority [priority2]
   priority 104
   priority 204
  ql-enabled
  wait-to-restore 0
!
!
end

```

=>以上是一个Router的配置文件，基本上也是CCNA能够涵盖的概念

# AWS 2024.8.20

## 创建VPC与EC2

> 在AWS上构建一个由20台服务器组成的网络涉及多个步骤，包括创建虚拟私有云（VPC）、配置子网、启动EC2实例、设置安全组和网络配置等。以下是一个分步指南，帮助你在AWS上构建这样一个网络：=>**NTC的CDB环境包括FS，FEP，USP等在内约有20台服务器组成**
>
> ### 1. **创建虚拟私有云（VPC）**
>
> 1. 登录到AWS Management Console: 访问 [AWS Management Console](https://aws.amazon.com/console/) 并登录到你的账户。
> 2. 导航到VPC控制台:
>    - 在控制台主页中，搜索并选择 “VPC”。
> 3. 创建VPC:
>    - 在左侧菜单中选择“Your VPCs”，然后点击“Create VPC”。
>    - 输入VPC名称，**选择IPv4 CIDR块**（例如 `10.0.0.0/16`），可以选择IPv6 CIDR块（可选）。
>    - 选择“Create”以创建VPC。  =>**会创建一个默认的路由表**
>
> ### 2. **创建子网**
>
> 1. 导航到子网页面:
>    - 在VPC控制台左侧菜单中，选择“Subnets”，然后点击“Create subnet”。
> 2. 配置子网:
>    - 选择刚刚创建的VPC。
>    - 输入子网名称和CIDR块。为了构建20台服务器，你可以创建多个子网。例如，可以创建两个子网，每个子网拥有 `10.0.1.0/24` 和 `10.0.2.0/24`，每个子网支持最多254个IP地址。=>**在VPC CIDR基础上设置子网的CIDR，NTC的CDB环境至少要有四个子网吧**
>    - 点击“Create subnet”。
> 3. 重复上述步骤，根据需要创建更多的子网。
>
> ### 3. 创建和配置互联网网关（IGW）
>
> 1. 创建互联网网关: **=>互联网网关就不需要了，在公有子网创建的NAT也不需要**
>    - 在VPC控制台中，选择“Internet Gateways”然后点击“Create internet gateway”。
>    - 输入名称，点击“Create”。
> 2. 附加互联网网关到VPC:
>    - 选择刚刚创建的互联网网关。
>    - 点击“Actions” > “Attach to VPC”，然后选择你的VPC并附加。
>
> ### 4. **配置路由表**
>
> 1. 创建路由表:  **=>路由表没法组织同一个VPC中不同子网通信，但可以通过ACL和Security Group来实现**
>    - 在VPC控制台中，选择“Route Tables”，然后点击“Create route table”。
>    - 选择VPC并输入路由表名称，点击“Create”。
> 2. 编辑路由表:
>    - 选择刚创建的路由表。
>    - 在“Routes”选项卡中，点击“Edit routes”，然后添加一条路由，目标为 `0.0.0.0/0`，目标为刚创建的互联网网关ID。
>    - 点击“Save routes”。
> 3. 将路由表关联到子网:  =>；路由表是跟子网关联的，
>    - 在“Subnet Associations”选项卡中，点击“Edit subnet associations”。
>    - 选择你之前创建的子网，然后点击“Save”。
>
> ### 5. **启动EC2实例**
>
> 1. 导航到EC2控制台:
>    - 在控制台主页中，搜索并选择“EC2”。
> 2. 启动实例: =>**在AWS中，一个EC2实例无法直接同时位于两个不同的子网中。一个EC2实例可以附加多个网络接口（ENI，Elastic Network Interface），每个网络接口可以在不同的子网中。通过这种方式，你可以让一个实例在多个子网中存在，但每个网络接口只能属于一个子网。**
>    - 点击“Launch Instance”。
>    - 选择AMI（例如 Amazon Linux 2 AMI）。
>    - 选择实例类型（例如 t3.micro）。
>    - 配置实例（选择你创建的VPC和子网，分配IP地址，选择“Auto-assign Public IP”）。
>    - 添加存储（根据需要进行调整）。
>    - 配置安全组（创建一个新的安全组或选择现有的，确保安全组规则允许必要的流量，比如端口22用于SSH访问）。
>    - 点击“Launch”，并选择一个密钥对（如果没有，可以创建一个新的密钥对）。
> 3. 重复上述步骤，启动20台实例。
>
> ### 6. **配置安全组**
>
> 1. 编辑安全组 **=>可以用这个来控制每个EC2的流量traffic的规则**
>    - 在EC2控制台中，选择“Security Groups”。**=> 这里还有根据条件添加Elastic IP的概念**
>    - 选择你用来配置实例的安全组。 **=>还可以给单独一台私网中的EC2配置一个IAM去访问像S3的数据库**
>    - 点击“Edit inbound rules”，配置规则以允许必要的流量（例如，允许SSH从你的IP地址访问）。
>
> ### 7. **测试和验证**
>
> 1. 检查实例:  
>    - 在EC2控制台中，确保所有20台实例都在运行状态。
>    - 确保每个实例都具有公共IP地址（如果需要从外部访问），并验证它们的网络连接。
> 2. 连接到实例:
>    - 使用SSH客户端（例如，PuTTY或Terminal）连接到每台实例，确保可以成功登录并运行基本的测试。
>
> 通过这些步骤，你可以在AWS上成功构建一个由20台服务器组成的网络。这些服务器可以部署应用程序、处理数据或作为测试环境。你可以根据需要进一步配置网络设置、存储和其他AWS服务。

=>创建1个VPC，3个Subnets，20个EC2 来构建CDB环境，至于最后CloudFormation用不用呢？非必要不展开

## CloudFormation YAML

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Description: A sample CloudFormation template to create a VPC with 3 subnets and 20 EC2 instances.

Resources:
  # 创建 VPC
  MyVPC:
    Type: 'AWS::EC2::VPC'
    Properties: 
      CidrBlock: '10.0.0.0/16'
      Tags:
        - Key: Name
          Value: MyVPC

  # 创建 Internet 网关
  MyInternetGateway:
    Type: 'AWS::EC2::InternetGateway'
    Properties:
      Tags:
        - Key: Name
          Value: MyInternetGateway

  # 互联网网关与 VPC 关联
  AttachInternetGateway:
    Type: 'AWS::EC2::VPCGatewayAttachment'
    Properties:
      VpcId: !Ref MyVPC
      InternetGatewayId: !Ref MyInternetGateway

  # 创建子网
  MySubnetA:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: '10.0.1.0/24'
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: MySubnetA

  MySubnetB:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: '10.0.2.0/24'
      AvailabilityZone: !Select [1, !GetAZs '']
      Tags:
        - Key: Name
          Value: MySubnetB

  MySubnetC:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: '10.0.3.0/24'
      AvailabilityZone: !Select [2, !GetAZs '']
      Tags:
        - Key: Name
          Value: MySubnetC

  # 创建路由表
  MyRouteTable:
    Type: 'AWS::EC2::RouteTable'
    Properties:
      VpcId: !Ref MyVPC
      Tags:
        - Key: Name
          Value: MyRouteTable

  # 创建默认路由
  MyDefaultRoute:
    Type: 'AWS::EC2::Route'
    Properties:
      RouteTableId: !Ref MyRouteTable
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref MyInternetGateway

  # 将子网与路由表关联
  MySubnetARouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Properties:
      SubnetId: !Ref MySubnetA
      RouteTableId: !Ref MyRouteTable

  MySubnetBRouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Properties:
      SubnetId: !Ref MySubnetB
      RouteTableId: !Ref MyRouteTable

  MySubnetCRouteTableAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    Properties:
      SubnetId: !Ref MySubnetC
      RouteTableId: !Ref MyRouteTable

  # 创建 EC2 实例
  MyInstance1:
    Type: 'AWS::EC2::Instance'
    Properties:
      InstanceType: 't2.micro'
      ImageId: 'ami-0c55b159cbfafe1f0' # Update with a valid AMI ID for your region
      SubnetId: !Ref MySubnetA
      Tags:
        - Key: Name
          Value: MyInstance1

  # 重复创建 EC2 实例
  # 可以用 AWS::CloudFormation::Stack 来包含多个实例的模板
  # 这里仅展示如何定义单个实例

Outputs:
  VPCId:
    Description: 'The ID of the VPC'
    Value: !Ref MyVPC

  SubnetAId:
    Description: 'The ID of Subnet A'
    Value: !Ref MySubnetA

  SubnetBId:
    Description: 'The ID of Subnet B'
    Value: !Ref MySubnetB

  SubnetCId:
    Description: 'The ID of Subnet C'
    Value: !Ref MySubnetC

  InstanceId:
    Description: 'The ID of Instance 1'
    Value: !Ref MyInstance1

```

## 使用CloudFormation配置VPC

> ### 使用CloudFormation配置VPC的步骤
>
> #### 1. **保存模板**
>
> 将上述模板保存为一个YAML文件，例如 `vpc-template.yaml`。
>
> #### 2. **登录到AWS管理控制台**
>
> - 访问 [AWS Management Console](https://aws.amazon.com/console/) 并登录到你的AWS账户。
>
> #### 3. **创建CloudFormation Stack**
>
> 通过AWS管理控制台：
>
> 1. 导航到CloudFormation控制台：
>    - 在控制台主页中，搜索并选择“CloudFormation”。
> 2. 创建一个新的Stack：
>    - 点击“Create stack”按钮。
>    - 选择“With new resources (standard)”选项。
> 3. 上传模板文件：
>    - 在“Specify template”部分，选择“Upload a template file”。
>    - 点击“Choose file”按钮，选择保存的YAML文件，然后点击“Next”。
> 4. 配置Stack：
>    - 在“Specify stack details”页面，输入Stack名称（如 `MyVPCStack`）。
>    - 根据需要填写其他参数（如果模板中定义了参数）。
> 5. 配置堆栈选项：
>    - 在“Configure stack options”页面，你可以配置标签、权限和其他选项。
>    - 默认设置通常适合大多数情况，可以直接点击“Next”。
> 6. 审查并创建：
>    - 在“Review”页面，检查你的设置并确保一切正确。
>    - 点击“Create stack”以开始创建堆栈。
> 7. 监控进度：
>    - 返回到CloudFormation控制台，你会看到堆栈的创建进度。
>    - 创建完成后，你可以在“Stacks”页面中查看堆栈的详细信息和创建的资源。

=>很简单，就是选择YAML文件，勾几个选项，直接自动部署VPC环境。

# Linux驱动开发

书籍：Linux设备驱动开发详解：基于最新的Linux4.0内核

## 1 Linux设备驱动概述及开发环境构建 2024.8.2

### 1.1 设备驱动的作用

驱动与底层硬件直接打交道，按照硬件设备的具体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的
映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。

### 1.2 无操作系统时的设备驱动

一个无限循环中夹杂着对设备中断的检测或者对设备的轮询是这种系统中软件的典型架构. 在没有操作系统的情况下，设备驱动的接口被直接提交给应用软件工程师，应用软件没有跨越任何层次就直接访问设备驱动的接口。

=>操作系统用来进度调用的嘛，单进程的设备真的无需操作系统了，直接开机Bootloader启动main

### 1.3 有操作系统时的设备驱动

需要将驱动融入内核。为了实现这种融合，必须在所有设备的驱动中设计面向操作系统内核的接口，这样的接口由操作系统规定，对一类设备而言结构一致，独立于具体的设备。由此可见，当系统中存在操作系统的时候，驱动变成了连接硬件和内核的桥梁。把单一的“驱使硬件设备行动”变成了操作系统内与硬件交互的模块，**它对外呈现为操作系统的API，不再给应用软件工程师直接提供接口。**

操作系统通过给驱动制造麻烦来达到给上层应用提供便利的目的。当驱动都按照操作系统给出的独立于设备的接口而设计时，那么，应用程序将可使用统一的系统调用接口来访问各种设备。对于类UNIX的VxWorks、Linux等操作系统而言，当应用程序通过write（）、read（）等函数读写文件就可访问各种字符设备和块设备，而不论设备的具体类型和工作方式，那将是多么便利。

=>虽然对于驱动而言，似乎用不着操作系统的并发控制与内存管理两个最主要的功能，但可以被OS规范接口

### 1.4 Linux设备驱动

Linux将存储器和外设分为3个基础大类:字符设备，块设备，网络设备

编写Linux设备驱动要求工程师有非常好的硬件基础，懂得SRAM、Flash、SDRAM、磁盘的读写方式，UART、I2C、USB等设备的接口以及轮询、中断、DMA的原理，PCI总线的工作方式以及CPU的内存管理单元（MMU）等

编写Linux设备驱动要求工程师有非常好的多任务并发控制和同步的基础，因为在驱动中会大量使用自旋锁、互斥、信号量、等待队列等并发与同步机制。

### 1.5 Linux设备驱动的开发环境构建

在Linux主机上阅读和编辑Linux源码的常用方式是vim+cscope或者vim+ctags

### 1.6 设备驱动Hello World：LED驱动

## 2 驱动设计的硬件基础 2024.8.6

### 2.1 处理器

网络处理器是一种可编程器件，它应用于电信领域的各种任务，如包处理、协议分析、路由查找、声音/数据的汇聚、防火墙、QoS等。网络处理器器件内部通常由若干个微码处理器和若干硬件协处理器组成，多个微码处理器在网络处理器内部并行处理，通过**预先编制的微码**来控制处理流程。而对于一些复杂的标准操作（如内存操作、路由表查找算法、QoS的拥塞控制算法、流量调度算法等），则采用硬件协处理器来进一步提高处理性能，从而实现了业务灵活性和高性能的有机结合。

### 2.2 存储器

存储器主要可分类为只读储存器（ROM）、闪存（Flash）、随机存取存储器（RAM）、光/磁介质储存器。

### 2.3 接口与总线 

SPI（Serial Peripheral Interface，串行外设接口）总线系统是一种同步串行外设接口，它可以使CPU与各种外围设备以串行方式进行通信以交换信息.

=>可以把SPI看成芯片内部的USB？



**以太网接口**：以太网接口由MAC（以太网媒体接入控制器）和PHY（物理接口收发器）组成。以太网MAC由IEEE802.3以太网标准定义，实现了数据链路层。MAC和PHY之间采用MII（媒体独立接口）连接，它是IEEE-802.3定义的以太网行业标准，包括1个数据接口与MAC和PHY之间的1个管理接口. 许多处理器内部集成了MAC或同时集成了MAC和PHY，另有许多以太网控制芯片也集成了MAC和PHY。

### 2.4 CPLD和FPGA

CPLD（复杂可编程逻辑器件）由完全可编程的与或门阵列以及宏单元构成。与CPLD不同，FPGA（现场可编程门阵列）基于LUT（查找表）工艺。查找表本质上是一片RAM，当用户通过原理图或HDL（硬件描述语言）描述了一个逻辑电路以后，FPGA开发软件会自动计算逻辑电路所有可能的结果，并把结果事先写入RAM。这样，输入一组信号进行逻辑运算就等于输入一个地址进行查表以输出对应地址的内容。

对于驱动工程师而言，我们只需要这样看待CPLD和FPGA：如果它完成的是特定的接口和控制功能，我们就直接把它当成由很多逻辑门（与、非、或、D触发器）组成的可完成一系列时序逻辑和组合逻辑的ASIC；如果它完成的是CPU的功能，我们就直接把它当成CPU。驱动工程师眼里的硬件比IC设计师要宏观。

> ASIC（Application-Specific Integrated Circuit，应用特定集成电路）是一种为特定应用或任务设计的集成电路。这种芯片的设计是为了解决特定的需求或优化特定的功能，而不是作为通用用途的芯片。与通用的集成电路（如CPU或GPU）不同，ASIC通常是为了实现某一特定功能或任务而量身定制的。

### 2.5 原理图分析

### 2.6 硬件时序分析

### 2.7 芯片数据手册阅读方法

芯片数据手册往往长达数百页，甚至上千页，而且全部是英文，从头到尾不加区分地阅读需要花费非常长的时间，而且不一定能获取对设计设备驱动有帮助的信息。芯片数据手册的正确阅读方法是快速而准确地定位有用信息，重点阅读这些信息，忽略无关内容

### 2.8 仪器仪表使用

示波器是利用电子示波管的特性，将人眼无法直接观测的交变电信号转换成图像，显示在荧光屏上以便测量的电子仪器。它是观察数字电路实验现象、分析实验中的问题、测量实验结果必不可少的重要仪器。

## 3 Linux内核及内核编程 2024.8.13

### 3.1 Linux内核的发展与演变

### 3.2 Linux 2.6后的内核特点

### 3.3 Linux内核的组成

·init：内核初始化代码。**著名的**start_kernel（）就位于init/main.c文件中。

一般的SoC内嵌入了bootrom，上电时bootrom运行。对于CPU0而言，bootrom会去引导bootloader，而其他CPU则判断自己是不是CPU0，进入WFI的状态等待CPU0来唤醒它。CPU0引导bootloader，bootloader引导Linux内核，在内核启动阶段，CPU0会发中断唤醒CPU1，之后CPU0和CPU1都投入运行。**CPU0导致用户空间的init程序被调用，init程序再派生其他进程**，派生出来的进程再派生其他进程。



Linux内核主要由进程调度（SCHED）、内存管理（MM）、虚拟文件系统（VFS）、网络接口（NET）和进程间通信（IPC）5个子系统组成。

网络接口:提供了对各种网络标准的存取和各种网络硬件的支持。在Linux中网络接口可分为网络协议和网络驱动程序，网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备通信，每一种可能的硬件设备都有相应的设备驱动程序。

### 3.4 Linux内核的编译及加载

Linux内核的编译:

Linux驱动开发者需要牢固地掌握Linux内核的编译方法以为嵌入式系统构建可运行的Linux操作系统映像。在编译内核时，需要配置内核，可以使用下面命令中的一个：在配置Linux内核所使用的make config、make menuconfig、make xconfig和make gconfig这4种方式中，最值得推荐的是make menuconfig，它不依赖于QT或GTK+，且非常直观，对/home/baohua/develop/linux中的Linux 4.0-rc1内核运行make ARCH=arm menuconfig后...

Linux内核的配置系统由以下3个部分组成:

 ·Makefile：分布在Linux内核源代码中，定义Linux内核的编译规则;

·配置文件（Kconfig）：给用户提供配置选择的功能;

·配置工具：包括配置命令解释器（对配置脚本中使用的配置命令进行解释）和配置用户界面（提供字符界面和图形界面）。这些配置工具使用的都是脚本语言，如用Tcl/TK、Perl等。



使用make config、make menuconfig等命令后，会生成一个.config配置文件，记录哪些部分被编译入内核、哪些部分被编译为内核模块。

> 在Linux内核开发中，“编译入内核”（build-in）和“编译为内核模块”（module）是两种不同的方式来集成驱动程序或功能。
>
> ### 编译入内核（Built-in）
>
> 1. **定义**: 将驱动程序或功能直接编译到内核映像中。它会成为内核的一部分，不需要额外的模块文件。
> 2. **优点**:
>    - **启动时加载**: 驱动程序在内核启动时已经加载，无需额外的加载步骤。
>    - **性能**: 由于不需要模块加载和卸载的开销，可能会略有性能优势。
>    - **简化**: 对于某些嵌入式系统或专用设备，所有功能编译到一个内核中可以简化管理。
> 3. **缺点**:
>    - **灵活性差**: 每次更新驱动程序或功能都需要重新编译整个内核。
>    - **内核膨胀**: 编译大量功能到内核可能会增加内核的大小和复杂性，可能导致启动时间变长或者内存占用增加。
>
> ### 编译为内核模块（Loadable Kernel Module, LKM）
>
> 1. **定义**: 将驱动程序或功能编译成独立的模块文件（.ko 文件），可以在运行时加载到内核中，也可以在不需要时卸载。
> 2. **优点**:
>    - **灵活性**: 可以根据需要加载和卸载模块，方便进行动态管理和调试。
>    - **内核精简**: 内核可以保持相对精简，减少了不必要的代码和功能。
>    - **模块更新**: 更新模块时只需重新编译模块，而不需要重新编译整个内核。
> 3. **缺点**:
>    - **模块管理**: 需要处理模块的加载和卸载，增加了管理的复杂性。
>    - **启动时间**: 在启动时，模块需要额外的加载步骤，可能稍微增加启动时间。
>
> ### 选择的依据
>
> - **编译入内核**: 适用于必须在所有时间内可用的功能，或对性能要求很高的系统。也适合那些不打算经常更改或更新的驱动程序。
> - **编译为模块**: 适用于可以按需加载的驱动程序或功能，或者在需要灵活管理和快速更新的场景下更为适合。对于常见的外部设备驱动程序，通常建议使用模块化的方法。
>
> 在实际应用中，选择哪种方式取决于系统需求、开发和维护的便利性以及性能考虑。

=>这里！如果编译驱动的话，肯定选择Loadable Kernel Module, LKM， 即.ko 文件！

=>Linux内核编译也是通过Makefile文件



在Linux内核中增加程序需要完成以下3项工作：

·将编写的源代码复制到Linux内核源代码的相应目录中。 =>一般而言，驱动开发者会在内核源代码的drivers目录内的相应子目录中增加新设备驱动的源代码

·在目录的Kconfig文件中增加关于新源代码对应项目的编译配置选项。

·在目录的Makefile文件中增加对新源代码的编译条目。

=>被问到内核编译的时候可以将这个哈

### 3.5 Linux下的C编程特点

GNU C与ANSI C：

GNU C允许使用零长度数组，

```c
struct var_data {
int len;
char data[0];
};
```

char data[0]仅仅意味着程序中通过var_data结构体实例的data[index]成员可以访问len之后的第index个地址，它并没有为data[]数组分配内存，因此sizeof（struct var_data）=sizeof（int）。

GNU C中也可以使用1个变量定义数组，例如如下代码中定义的“double x[n]”：

```c
int main (int argc, char *argv[])
{
int i, n = argc;
double x[n];
for (i = 0; i < n; i++)
x[i] = i;
return 0;
}
```

=>可变数组！内存不安全啊

=>区别零零碎碎有讲了十多条



用不用goto一直是一个著名的争议话题，Linux内核源代码中对goto的应用非常广泛，但是一般只限于错误处理中

### 3.6 工具链

### 3.7 实验室建设

### 3.8 串口工具

### 3.9 总结

在Linux内核方面，主要介绍了Linux内核的发展史、组成、特点、源代码结构、内核编译方法及内核引导过程。

由于Linux驱动编程本质属于内核编程，因此掌握内核编程的基础知识显得尤为重要。本章在这方面主要讲解了在内核中新增程序、目录和编写Kconfig和Makefile的方法，并分析了Linux下C编程习惯以及Linux所使用的GNU C针对标准C的扩展语法。

## 4 Linux内核模块 2024.8.15

### 4.1 Linux内核模块简介

=>内核模块 是 避免将 所有功能编入到Linux内核防止 内核臃肿，最简单的内核模块：

```c
/*
 * a simple kernel module: hello
 *
 * Copyright (C) 2014 Barry Song (baohua@kernel.org)
 *
 * Licensed under GPLv2 or later.
 */

#include <linux/init.h>
#include <linux/module.h>

static int __init hello_init(void)
{
 printk(KERN_INFO "Hello World enter\n");
 return 0;
}
module_init(hello_init);

static void __exit hello_exit(void)
{
 //内核模块中用于输出的函数是内核空间的printk（）而不是用户空间的printf（），printk（）可定义输出级别。printk（）可作为一种最基本的内核调试手段
 printk(KERN_INFO "Hello World exit\n ");
}
module_exit(hello_exit);

MODULE_AUTHOR("Barry Song <21cnbao@gmail.com>");
MODULE_LICENSE("GPL v2");
MODULE_DESCRIPTION("A simple Hello World Module");
MODULE_ALIAS("a simplest module");
```

这个最简单的内核模块只包含**内核模块加载函数、卸载函数**和对GPL v2许可权限的声明以及一些描述信息，编译它会**产生hello.ko目标文件**，通过“insmod./hello.ko”命令可以加载它，通过“rmmod hello”命令可以卸载它，加载时输出“Hello World enter”，卸载时输出“Hello World exit”。

在Linux中，使用**lsmod**命令可以获得系统中已加载的所有模块以及模块间的依赖关系:lsmod命令实际上是读取并分析“/proc/modules”文件

### 4.2 Linux内核模块程序结构

一个Linux内核模块主要由如下几个部分组成。

1. 模块加载函数
2. 模块卸载函数
3. 模块许可证声明

=>了解一下linux内核模块的大框架

### 4.3 模块加载函数

在Linux内核中，可以使用request_module（const char*fmt，…）函数加载内核模块，驱动开发人员可以通过调用下列代码：

```c
request_module(module_name);
```

### 4.4 模块卸载函数

### 4.5 模块参数

### 4.6 导出符号

### 4.7 模块声明与描述

### 4.8 模块的使用计数

### 4.9 模块的编译

我们可以为代码清单4.1的模板编写一个简单的Makefile：

```shell
KVERS = $(shell uname -r)
# Kernel modules
obj-m += hello.o
# Specify flags for the module compilation.
#EXTRA_CFLAGS=-g -O0
build: kernel_modules
kernel_modules:
make -C /lib/modules/$(KVERS)/build M=$(CURDIR) modules
clean:
make -C /lib/modules/$(KVERS)/build M=$(CURDIR) clean
```

### 4.10 使用模块“绕开”GPL

### 4.11 总结

本章主要讲解了Linux内核模块的概念和基本的编程方法。内核模块由加载/卸载函数、功能函数以及一系列声明组成，它可以被传入参数，也可以导出符号供其他模块使用。

由于Linux设备驱动以内核模块的形式存在，因此，掌握这一章的内容是编写任何设备驱动的必需。

## 5 Linux文件系统与设备文件

### 5.1 Linux文件操作

5.1.1 文件操作系统调用

Linux的文件操作系统调用（在Windows编程领域，习惯称操作系统提供的接口为API）涉及创建、打开、读写和关闭文件。

```c
//创建
int creat(const char *filename, mode_t mode);
//打开
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
//读写
int read(int fd, const void *buf, size_t length);
int write(int fd, const void *buf, size_t length);
//定位
int lseek(int fd, offset_t offset, int whence);
//关闭
int close(int fd);
```

7（1+2+4，读、写、执行）、0（没有权限）、5（1+4，读、执行

5.1.2 C库文件操作

C库函数的文件操作实际上独立于具体的操作系统平台，不管是在DOS、Windows、Linux还是在VxWorks中都是这些函数：

```c
//创建和打开
fiLE *fopen(const char *path, const char *mode);
//读写
int fgetc(fiLE *stream);
int fputc(int c, fiLE *stream);
char *fgets(char *s, int n, fiLE *stream);
int fputs(const char *s, fiLE *stream);
int fprintf(fiLE *stream, const char *format, ...);
int fscanf (fiLE *stream, const char *format, ...);
size_t fread(void *ptr, size_t size, size_t n, fiLE *stream);
size_t fwrite (const void *ptr, size_t size, size_t n, fiLE *stream);
//关闭
int fclose (fiLE *stream);
```

=>注意C库文件操作函数 包裹着 作为 系统调用的 Linux文件操作系统调用 哈

### 5.2 Linux文件系统

在设备驱动程序的设计中，一般而言，会关心file和inode这两个结构体。

file结构体代表一个打开的文件，系统中每个打开的文件在内核空间都有一个关联的struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。

VFS inode包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁

=>应用程序 => VFS => 设备文件/dev/ => 设备驱动 => 设备， 所以应用程序用C库文件操作函数，而驱动的话还是要用Linux API，对吧？

### 5.3 devfs

### 5.4 udev用户空间设备管理

在Linux 2.6内核中，devfs被认为是过时的方法，并最终被抛弃了，udev取代了它 => devfs应该下课，因为策略应该位于用户空间而不是内核空间。

Linux 2.6以后的内核引入了sysfs文件系统，sysfs被看成是与proc、devfs和devpty同类别的文件系统，该文件系统是一个虚拟的文件系统，它可以产生一个包括所有系统硬件的层级视图，与提供进程和状态信息的proc文件系统十分类似。

udev在用户空间中执行，动态建立/删除设备文件

### 5.5 总结

Linux用户空间的文件编程有两种方法，即通过Linux API和通过C库函数访问文件。用户空间看不到设备驱动，能看到的只有与设备对应的文件，因此文件编程也就是用户空间的设备编程。

## 6 字符设备驱动

字符设备是3大类设备（字符设备、块设备和网络设备）中的一类，其驱动程序完成的主要工作是初始化、添加和删除cdev结构体，申请和释放设备号，以及填充file_operations结构体中的操作函数，实现file_operations结构体中的read（）、write（）和ioctl（）等函数是驱动设计的主体工作。

## 7 Linux设备驱动中的并发控制

### 7.1 并发与竞态

并发（Concurrency）指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全局变量、静态变量等）的访问则很容易导致竞态（Race Conditions）

解决竞态问题的途径是保证对共享资源的互斥访问，所谓互斥访问是指一个执行单元在访问共享资源的时候，其他的执行单元被禁止访问。

访问共享资源的代码区域称为临界区（Critical Sections），临界区需要被以某种互斥机制加以保护。中断屏蔽、原子操作、自旋锁、信号量、互斥体等是Linux设备驱动中可采用的互斥途径。

### 7.2 编译乱序和执行乱序

解决编译乱序问题，需要通过barrier（）编译屏障进行。我们可以在代码中设置barrier（）屏障，这个屏障可以阻挡编译器的优化。对于编译器来说，设置编译屏障可以保证屏障前的语句和屏障后的语句不乱“串门”。

关于解决编译乱序的问题，C语言volatile关键字的作用较弱，它更多的只是避免内存访问行为的合并，对C编译器而言，volatile是暗示除了当前的执行线索以外，其他的执行线索也可能改变某内存，**所以它的含义是“易变的”**。换句话说，就是如果线程A读取var这个内存中的变量两次而没有修改var，编译器可能觉得读一次就行了，第2次直接取第1次的结果。但是如果加了volatile关键字来形容var，则就是告诉编译器线程B、线程C或者其他执行实体可能把var改掉了，因此编译器就不会再把线程A代码的第2次内存读取优化掉了。另外，volatile也不具备保护临界资源的作用。总之，Linux内核明显不太喜欢volatile

> ```c
> volatile int hardware_register;
> volatile int flag;
> 
> void interrupt_handler() {
>     flag = 1; // 修改标志变量
> }
> 
> void main() {
>     flag = 0;
>     while (flag == 0) {
>         // 等待中断处理程序设置 flag
>     }
>     // 处理中断后的逻辑
> }
> ```
>
> 在这个示例中，`flag` 变量被声明为 `volatile`，因为它可能会被中断处理程序修改。如果没有 `volatile`，编译器可能会优化掉 `while (flag == 0)` 这个循环，使其成为一个死循环，因为编译器可能认为 `flag` 在循环中不会改变。
>
> 总结:**`volatile` 的关键作用是避免编译器对被标记变量的优化，以确保每次访问都从内存中读取最新的值。**在涉及硬件寄存器、处理中断以及多线程编程时，使用 `volatile` 是确保程序正确性的一个重要方面。

### 7.3 中断屏蔽

### 7.4 原子操作

### 7.5 自旋锁

### 7.6 信号量

信号量（Semaphore）是操作系统中最典型的用于同步和互斥的手段，信号量的值可以是0、1或者n。

作为一种可能的互斥手段，信号量可以保护临界区，它的使用方式和自旋锁类似

由于新的Linux内核倾向于直接使用mutex作为互斥手段，信号量用作互斥不再被推荐使用。

### 7.7 互斥体

尽管信号量已经可以实现互斥的功能，但是“正宗”的mutex在Linux内核中还是真实地存在着。

mutex的使用方法和信号量用于互斥的场合完全一样：

```c
struct mutex my_mutex; /* 定义mutex */
mutex_init(&my_mutex); /* 初始化mutex */
mutex_lock(&my_mutex); /* 获取mutex */
... /* 临界资源*/
mutex_unlock(&my_mutex); /* 释放mutex */
```

### 7.8 完成量

### 7.9 增加并发控制后的globalmem的设备驱动

### 7.10 总结

=>主要还是就是Mutex，关于Semaphore也可以实现与Mutex类似的效果，但是我确实没太用过，如实回答

## 8 Linux设备驱动中的阻塞与非阻塞I/O 2024.8.16

### 8.1 阻塞与非阻塞I/O

阻塞操作是指在执行设备操作时，若不能获得资源，则挂起进程直到满足可操作的条件后再进行操作。被挂起的进程进入睡眠状态，被从调度器的运行队列移走，直到等待的条件被满足。而非阻塞操作的进程在不能进行设备操作时，并不挂起，它要么放弃，要么不停地查询，直至可以进行操作为止。

在Linux驱动程序中，可以使用等待队列（Wait Queue）来实现阻塞进程的唤醒。

所谓死锁，就是多个进程循环等待他方占有的资源而无限期地僵持下去。如果没有外力的作用，那么死锁涉及的各个进程都将永远处于封锁状态。因此，驱动工程师一定要注意：当多个等待队列、信号量、互斥体等机制同时出现时，谨防死锁！

> 避免死锁的策略:
>
> 确保所有线程以相同的顺序请求资源。这样可以避免循环等待，从而减少死锁的风险。例如，如果你有两个资源 A 和 B，确保所有线程都先请求 A 然后请求 B，而不是相反的顺序。
>
> ```c
> #include <pthread.h>
> #include <stdio.h>
> #include <stdlib.h>
> 
> pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
> pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;
> 
> void* thread1_func(void* arg) {
>     pthread_mutex_lock(&mutex1);
>     printf("Thread 1 acquired mutex1\n");
>     
>     // Simulate some work
>     sleep(1);
>     
>     pthread_mutex_lock(&mutex2);
>     printf("Thread 1 acquired mutex2\n");
>     
>     // Simulate some work
>     sleep(1);
>     
>     pthread_mutex_unlock(&mutex2);
>     pthread_mutex_unlock(&mutex1);
>     return NULL;
> }
> 
> void* thread2_func(void* arg) {
>     pthread_mutex_lock(&mutex2);
>     printf("Thread 2 acquired mutex2\n");
>     
>     // Simulate some work
>     sleep(1);
>     
>     pthread_mutex_lock(&mutex1);
>     printf("Thread 2 acquired mutex1\n");
>     
>     // Simulate some work
>     sleep(1);
>     
>     pthread_mutex_unlock(&mutex1);
>     pthread_mutex_unlock(&mutex2);
>     return NULL;
> }
> 
> int main() {
>     pthread_t t1, t2;
>     
>     pthread_create(&t1, NULL, thread1_func, NULL);
>     pthread_create(&t2, NULL, thread2_func, NULL);
>     
>     pthread_join(t1, NULL);
>     pthread_join(t2, NULL);
>     
>     return 0;
> }
> 
> ```
>
> =>两个线程 两个锁

### 8.2 轮询操作

在用户程序中，select（）和poll（）也是与设备阻塞与非阻塞访问息息相关的论题。使用非阻塞I/O的应用程序通常会使用select（）和poll（）系统调用查询是否可对设备进行无阻塞的访问

当多路复用的文件数量庞大、I/O流量频繁的时候，一般不太适合使用select（）和poll（），此种情况下，select（）和poll（）的性能表现较差，我们宜使用epoll。epoll的最大好处是不会随着fd的数目增长而降低效率，select（）则会随着fd的数量增大性能下降明显

一般来说，当涉及的fd数量较少的时候，使用select是合适的；如果涉及的fd很多，**如在大规模并发的服务器中侦听许多socket**
**的时候，则不太适合选用select，而适合选用epoll。**

### 8.3 支持轮询操作的globalfifo驱动

### 8.4 总结

在设备驱动中阻塞I/O一般基于等待队列或者基于等待队列的其他Linux内核API来实现，等待队列可用于同步驱动中事件发生的先后顺序。使用非阻塞I/O的应用程序也可借助轮询函数来查询设备是否能立即被访问，用户空间调用select（）、poll（）或者epoll接口，设备驱动提供poll（）函数。设备驱动的poll（）本身不会阻塞，但是与poll（）、select（）和epoll相关的系统调用则会阻塞地等待至少一个文件描述符集合可访问或超时。

=>poll（）、select（）和epoll 是为 非阻塞I/O的应用程序 服务的

=> 阻塞 I/O" 在英文中通常称为 Blocking I/O

> 默认情况下，套接字（socket）使用的是阻塞 I/O（Blocking I/O）。这意味着当一个线程或进程执行 I/O 操作（如读取或写入套接字）时，如果操作无法立即完成，线程或进程会被阻塞，直到操作完成。
>
> 你可以将套接字设置为非阻塞模式，这样套接字操作不会阻塞线程或进程。
>
> ### 非阻塞 I/O 的优点
>
> - **提高并发性**：允许线程继续执行其他任务，而不是等待 I/O 操作完成。
> - **适合事件驱动编程**：与事件循环（如 `select`、`poll`、`epoll`、`kqueue`）结合使用，可以实现高效的事件驱动编程。

=> 套接字 是不是 Blocking I/O，你是可以设置的！ 当设置为非阻塞 I/O 时，就需要跟`select`、`poll`、`epoll`结合使用！后者可以阻塞等待

> `select` 会阻塞当前线程，直到其中至少一个被监视的文件描述符变得可读、可写或异常。
>
> `epoll` 是 Linux 特有的一种 I/O 多路复用机制，用于处理大量文件描述符的 I/O 事件。

## 9 Linux设备驱动中的异步通知与异步I/O

在设备驱动中使用异步通知可以使得在进行对设备的访问时，由**驱动主动通知应用程序**进行访问。这样，使用非阻塞I/O的应用程序无须轮询设备是否可访问，而阻塞访问也可以被类似“中断”的异步通知所取代。

除了异步通知以外，应用还可以在发起I/O请求后，立即返回。之后，再查询I/O完成情况，或者I/O完成后被调回。这个过程叫作异步I/O。

### 9.1 异步通知的概念与作用

异步通知的意思是：一旦设备就绪，则主动通知应用程序，这样应用程序根本就不需要查询设备状态，这一点非常类似于硬件上“中断”的概念，比较准确的称谓是“信号驱动的异步I/O”。信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。

阻塞、非阻塞I/O、异步通知本身没有优劣，应该根据不同的应用场景合理选择。

=>GSC模块中 非同期 不就是这个 异步通知 嘛！所以第8,9章的内容在NTC的时候还是可以找到对应的事例的！

### 9.2 Linux异步通知编程

使用信号进行进程间通信（IPC）是UNIX中的一种传统机制，Linux也支持这种机制。在Linux中，异步通知使用信号来实现

=>略微不一样，驱动层的异步通知编程 用的是 signal()， 应用层用的时queue

### 9.3 支持异步通知的globalfifo驱动

> `globalfifo` 是 Linux 内核中提供的一种全局缓冲区实现，用于高效的数据传输和处理。它允许不同的内核模块或组件在内核空间中共享数据，避免了用户空间与内核空间之间的数据传输开销。了解并使用 `globalfifo` 可以帮助你在内核模块开发中实现高效的数据交换和缓冲。
>
> ### 典型的使用场景
>
> 1. **内核模块间通信**：
>    - 在开发内核模块时，可能需要在不同的内核模块之间传输数据。`globalfifo` 提供了一个有效的方式来实现这一点。
> 2. **数据缓冲**：
>    - 在处理需要高效数据传输的内核功能时，例如网络数据处理、设备驱动程序等，`globalfifo` 可以作为数据缓冲区来优化数据的流动和处理。

> **与共享内存的区别**：
>
> - **使用场景**：共享内存通常用于用户空间进程间的数据交换，而 `globalfifo` 用于内核模块间的数据交换。
> - **实现层次**：共享内存通常是操作系统提供的进程间通信机制，涉及到用户空间和内核空间的交互；而 `globalfifo` 是在内核空间内部的缓冲区实现，主要在内核模块之间使用。

### 9.4 Linux异步I/O

=>描述了为用户空间提供了统一的异步I/O接口的AIO函数，没碰到过

### 9.5 总结

## 10 中断与时钟 2024.8.27

### 10.1 中断与定时器

中断可分为内部中断和外部中断，内部中断的中断源来自CPU内部（软件中断指令、溢出、除法错误等，例如，操作系统从用户态切换到内核态需借助CPU内部的软件中断），外部中断的中断源来自CPU外部，由外设提出请求。

### 10.2 Linux中断处理程序架构

### 10.3 Linux中断编程

=>讲解了一些用于中断的函数

### 10.4 中断共享

### 10.5 内核定时器

### 10.6 内核延时

### 10.7 总结

## 11 内存与I/O访问

### 11.1 CPU与内存、I/O

高性能处理器一般会提供一个内存管理单元（MMU），该单元辅助操作系统进行内存管理，提供虚拟地址和物理地址的映射、内存访问权限保护和Cache缓存控制等硬件支持

=>内核编程跟 计算机组成与结构 这门课还是联系很紧密的

### 11.2 Linux内存管理

在Linux系统中，进程的4GB内存空间被分为两个部分——用户空间与内核空间。用户空间的地址一般分布为0~3GB（即PAGE_OFFSET，在0x86中它等于0xC0000000），这样，剩下的3~4GB为内核空间，用户进程只有通过系统调用（代表用户进程在内核态执行）等方式才可以访问到内核空间。

对于32位的x86而言，在3~4GB之间的内核空间中，从低地址到高地址依次为：物理内存映射区→隔离带→vmalloc虚拟内存分配器区→隔离带→高端内存映射区→专用页面映射区→保留区。

直接进行映射的896MB物理内存其实又分为两个区域，在低于16MB的区域，ISA设备可以做DMA，所以该区域为DMA区域，16MB~896MB之间的为常规区域。高于896MB的就称为高端内存区域了。

=>DMA 有固定地址范围

### 11.3 内存存取

在用户空间中动态申请内存的函数为malloc（），这个函数在各种操作系统上的使用都是一致的，malloc（）申请的内存的释放函数为free（）。对于Linux而言，C库的malloc（）函数一般通过brk（）和mmap（）两个系统调用从**内核申请内存**。

由于用户空间C库的malloc算法实际上具备一个二次管理能力，所以并不是每次申请和释放内存都一定伴随着对内核的系统调用。free（）并不会把内存还给内核，而只是还给了C库的分配算法（内存仍然属于这个进程），因此之后所有的动态内存申请和释放都在用户态下进行。

### 11.4 设备I/O端口和I/O内存的访问

设备通常会提供一组寄存器来控制设备、读写设备和获取设备状态，即控制寄存器、数据寄存器和状态寄存器。这些寄存器可能位于I/O空间中，也可能位于内存空间中。当位于I/O空间时，通常被称为I/O端口；当位于内存空间时，对应的内存空间被称为I/O内存。

读寄存器用readb_relaxed（）、readw_relaxed（）、readl_relaxed（）、readb（）、readw（）、readl（）这一组API

> I/O内存"（Input/Output Memory）通常指的是计算机系统中用于输入和输出操作的内存区域。在计算机架构中，**I/O内存映射指的是将外部设备的寄存器映射到系统的地址空间中**，使得CPU可以通过读写内存地址来与这些外部设备进行交互。这种方式可以使设备的控制寄存器看起来像是普通的内存地址，从而简化了I/O操作。

一般情况下，用户空间是不可能也不应该直接访问设备的，但是，设备驱动程序中可实现mmap（）函数，这个函数可使得用户空间能直接访问设备的物理地址。实际上，mmap（）实现了这样的一个映射过程：它将用户空间的一段内存与设备内存关联，当用户访问用户空间的这段地址范围时，实际上会转化为对设备的访问。

大多数设备驱动都不需要提供设备内存到用户空间的映射能力，因为，对于串口等面向流的设备而言，实现这种映射毫无意义。而对于显示、视频等设备，建立映射可减少用户空间和内核空间之间的内存复制。

=> I/O内存 映射驱动设备寄存器， 我是完全没有接触过的...

### 11.5 I/O内存静态映射

### 11.6 DMA

DMA是一种无须CPU的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制。使用DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而大大提高系统的吞吐率。DMA通常与硬件体系结构，特别是外设的总线技术密切相关。

Linux下的DMA编程 =>也有相应的各种操作函数

### 11.7 总结

## 12 Linux设备驱动的软件架构思想本

### 12.1 Linux驱动的软件架构

将软件进行分层设计应该是软件工程最基本的一个思想

### 12.2 platform设备驱动

在Linux 2.6以后的设备驱动模型中，需关心总线、设备和驱动这3个实体，总线将设备和驱动绑定。

### 12.3 设备驱动的分层思想

我们已经从感性上认识了Linux驱动软件分层的意义。其实，在分层设计的时候，Linux内核大量使用了面向对象的设计思想。Linux内核完全是由C语言和汇编语言写成，但是却频繁地用到了面向对象的设计思想。在设备驱动方面，往往为同类的设备设计了一个框架，而框架中的核心层则实现了该设备通用的一些功能。同样的，如果具体的设备不想使用核心层的函数，也可以重写。

### 12.4 主机驱动与外设驱动分离的设计思想

> 在Linux系统中，SPI（Serial Peripheral Interface）是一种用于微控制器和外设之间进行高速串行通信的协议。SPI是一种常用的串行总线接口，广泛应用于各种嵌入式系统中，例如传感器、存储器、显示屏等设备。

### 12.5 总结

## 13 Linux块设备驱动

## 14 Linux网络设备驱动

网络设备是完成用户数据包在网络媒介上发送和接收的设备，它将上层协议传递下来的数据包以特定的媒介访问控制方式进行发送，并将接收到的数据包传递给上层协议。

与字符设备和块设备不同，网络设备并不对应于/dev目录下的文件，应用程序最终使用套接字完成与网络设备的接口。因而在网络设备身上并不能体现出“一切都是文件”的思想。

### 14.1 Linux网络设备驱动的结构

Linux系统对网络设备驱动定义了4个层次，这4个层次为网络协议接口层、网络设备接口层、提供实际功能的设备驱动功能层和网络设备与媒介层。

1. **网络协议接口层**向网络层协议提供统一的数据包收发接口，不论上层协议是ARP，还是IP，都通过dev_queue_xmit（）函数发送数据，并通过netif_rx（）函数接收数据。这一层的存在使得上层协议独立于具体的设备。
2. 网络设备接口层向协议接口层提供统一的用于描述具体网络设备属性和操作的结构体net_device，该结构体是设备驱动功能层中各函数的容器。实际上，网络设备接口层从宏观上规划了具体操作硬件的设备驱动功能层的结构。
3. 设备驱动功能层的各函数是网络设备接口层net_device数据结构的具体成员，是驱使网络设备硬件完成相应动作的程序，它通过hard_start_xmit（）函数启动发送操作，并通过网络设备上的中断触发接收操作。
4. 网络设备与媒介层是完成数据包发送和接收的物理实体，包括网络适配器和具体的传输媒介，网络适配器被设备驱动功能层中的函数在物理上驱动。对于Linux系统而言，网络设备和媒介都可以是虚拟的。



#### 14.1.1 网络协议接口层

当发送数据包时，Linux内核的网络处理模块必须建立一个包含要传输的数据包的sk_buff，然后将sk_buff递交给下层，各层在sk_buff中添加不同的协议头直至交给网络设备发送。同样地，当网络设备从网络媒介上接收到数据包后，它必须将接收到的数据转换为sk_buff数据结构并传递给上层，各层剥去相应的协议头直至交给用户

```c
struct sk_buff {
 /* These two members must be first. */
 struct sk_buff *next;
 struct sk_buff *prev;

 ...
 unsigned int len,
 data_len;
 __u16 mac_len,
 hdr_len;
 ...
 __u32 priority;
 ...
 __be16 protocol;

 ...

 __be16 inner_protocol;
 __u16 inner_transport_header;
 __u16 inner_network_header;
 __u16 inner_mac_header;
 __u16 transport_header;
 __u16 network_header;
 __u16 mac_header;
 /* These elements must be at the end, see alloc_skb() for details. */
 sk_buff_data_t tail;
 sk_buff_data_t end;
 unsigned char *head,
 *data;
 ...
};
```

#### 14.1.2 网络设备接口层

网络设备接口层的主要功能是为千变万化的网络设备定义统一、抽象的数据结构net_device结构体，以不变应万变，实现多种硬件在软件层次上的统一。

net_device结构体在内核中指代一个网络设备，它定义于include/linux/netdevice.h文件中，网络设备驱动程序只需通过填充net_device的具体成员并注册net_device即可实现硬件操作函数与内核的挂接。

base_addr为网络设备I/O基地址。
irq为设备使用的中断号。
if_port指定多端口设备使用哪一个端口，该字段仅针对多端口设备。例如，如果设备同时支持
IF_PORT_10BASE2（同轴电缆）和IF_PORT_10BASET（双绞线），则可使用该字段。
dma指定分配给设备的DMA通道。

=>字段中还有 DMA通道

hard_header_len是网络设备的硬件头长度，在以太网设备的初始化函数中，该成员被赋为ETH_HLEN，即14。
=>联系上了！感觉所谓的网络设备就是以太网卡，网络协议接口层给上面的IP或者ARP提供 透明信息，设备接口层就定义 以太网卡的一些信息？

mtu指最大传输单元（MTU）。

set_mac_address（）函数完成了memcpy（）以及最终硬件上的MAC地址变更。

ndo_open（）函数的作用是打开网络接口设备，获得设备需要的I/O地址、IRQ、DMA通道等。

#### 14.1.3 设备驱动功能层

net_device结构体的成员（属性和net_device_ops结构体中的函数指针）需要被设备驱动功能层赋予具体的数值和函数。对于具体的设备xxx，工程师应该编写相应的设备驱动功能层的函数，这些函数形如xxx_open（）、xxx_stop（）、xxx_tx（）、xxx_hard_header（）、xxx_get_stats（）和xxx_tx_timeout（）等。

由于网络数据包的接收可由中断引发，设备驱动功能层中的另一个主体部分将是中断处理函数，它负责读取硬件上接收到的数据包并传送给上层协议，因此可能包含xxx_interrupt（）和xxx_rx（）函数，前者完成中断类型判断等基本工作，后者则需完成数据包的生成及将其递交给上层等复杂工作。

### 14.2 网络设备驱动的注册与注销

网络设备驱动的注册与注销由register_netdev（）和unregister_netdev（）函数完成

### 14.3 网络设备的初始化

·进行硬件上的准备工作，检查网络设备是否存在，如果存在，则检测设备所使用的硬件资源。
·进行软件接口上的准备工作，分配net_device结构体并对其数据和函数指针成员赋值。
·获得设备的私有信息指针并初始化各成员的值。如果私有信息中包括自旋锁或信号量等并发或同步
机制，则需对其进行初始化。

=>这么看来上次的面试官对以太网驱动还是有一定了解的啊，考察了DMA，信号量等...

### 14.4 网络设备的打开与释放

网络设备的打开函数需要完成如下工作。
·使能设备使用的硬件资源，**申请I/O区域、中断和DMA通道**等。
·调用Linux内核提供的netif_start_queue（）函数，激活设备发送队列。
网络设备的关闭函数需要完成如下工作。
·调用Linux内核提供的netif_stop_queue（）函数，停止设备传输包。
·释放设备所使用的I/O区域、中断和DMA资源。

### 14.5 数据发送流程

网络设备驱动程序的数据包发送函数模板

```c
int xxx_tx(struct sk_buff *skb, struct net_device *dev)
{
 int len;
 char *data, shortpkt[ETH_ZLEN];
 if (xxx_send_available(...)) { /* 发送队列未满，可以发送 */
 /* 获得有效数据指针和长度 */
 data = skb->data;
 len = skb->len;
 if (len < ETH_ZLEN) {
 /* 如果帧长小于以太网帧最小长度，补0 */
 memset(shortpkt, 0, ETH_ZLEN);
 memcpy(shortpkt, skb->data, skb->len);
 len = ETH_ZLEN;
 data = shortpkt;
 }

 dev->trans_start = jiffies; /* 记录发送时间戳 */

 if (avail) {/* 设置硬件寄存器，让硬件把数据包发送出去 */
 xxx_hw_tx(data, len, dev);
 } else {
 netif_stop_queue(dev);
 ...
 }
}
```

=>设置寄存器，这么说来以前的微码操作就是寄存器了？那不是无需通过Linux吗

> 博通（Broadcom）的BCM系列交换芯片用于各种网络交换应用，它们通常涉及到复杂的网络数据处理。
>
> #### **a. 初始化和配置**
>
> - **初始化芯片：** 编写代码初始化交换芯片，包括设置寄存器、配置接口等。
> - **配置端口：** 配置每个端口的工作模式，如速率、双工模式等。
>
> #### **b. 数据路径处理**
>
> - **数据包处理：** 实现数据包的接收和发送，包括数据包的缓冲和转发。
> - **流量管理：** 实现流量控制、VLAN处理等功能。
>
> #### **c. 中断处理**
>
> - **中断服务例程：** 编写中断服务例程来处理芯片生成的中断，如数据包到达、错误报告等。
>
> #### **d. 错误处理和调试**
>
> - **错误处理：** 实现错误检测和恢复机制，确保驱动的稳定性。
> - **调试：** 使用调试工具（如printk日志、gdb、内核调试器）进行驱动程序的调试和优化。
>
> ### 5. **集成和测试**
>
> - **集成到内核中：** 将驱动程序集成到Linux内核中，编译内核并安装到目标系统。
> - **测试：** 在实际硬件上进行全面测试，确保驱动程序功能正常且稳定。

> **数据路径：** 在网络交换机中，交换芯片处理和转发数据包的主要工作。CPU通常不会直接参与数据包的转发，但可以通过控制和配置交换芯片来影响数据处理的方式。例如，CPU可以配置交换芯片的转发表、VLAN设置、QoS策略等。
>
> **控制平面与数据平面：** 交换芯片处理的是数据平面（Data Plane）任务，即实际的数据包转发。CPU处理的是控制平面（Control Plane）任务，包括网络协议的管理、设备配置、状态监控等。

> **网络交换机中的交换芯片** 可能会通过SPI、I2C或其他总线接口连接到CPU。CPU使用这些接口向交换芯片发送配置命令，例如设置端口速率、启用VLAN功能等。
>
> **驱动程序** 在Linux系统中，驱动程序通过操作系统的内核提供的API来控制和配置交换芯片。CPU通过这些API与驱动程序交互，进而实现对交换芯片的控制和管理。

> **数据流动：** 以太网卡与交换芯片都参与数据流的处理。在一个网络设备（如交换机）中，数据首先通过以太网卡接收，然后由交换芯片进行处理和转发。
>
> **集成设备：** 在一些网络设备中，特别是高性能交换机和路由器，交换芯片和以太网卡可能集成在一个单一的硬件平台中，以提高效率和减少延迟。
>
> **层次分离：** 以太网卡处理数据链路层的任务，而交换芯片处理数据平面任务。两者在网络协议栈中分别负责不同的层次。
>
> **交换芯片：** 工作在网络交换机中，主要负责数据包的转发、流量管理、VLAN支持等网络层面的操作。
>
> **以太网卡：** 安装在计算机或网络设备中，主要负责数据帧的发送和接收，处理数据链路层的任务。
>
> **交换芯片：** 设计为高吞吐量、高性能的网络设备，通常具备专用的硬件加速功能。
>
> **以太网卡：** 通常以较低成本和通用性能为目标，适用于一般的网络通信需求。
>
> **交换芯片示例：** Broadcom BCM56800系列交换芯片，Cisco Nexus系列交换芯片。
>
> **以太网卡（Ethernet Card）示例：** Intel Ethernet Controller I210，Broadcom NetXtreme系列网卡。

>  交换机内部集成了所有需要的网络接口，不需要外部的以太网卡。交换机端口直接连接到交换芯片，处理数据的交换和转发功能。现代交换机的设计通常包括所有必要的网络端口和交换芯片。这些端口可以直接连接到网络，而不需要外部的以太网卡。
>
> **计算机和服务器：** 在计算机和服务器中，如果它们需要连接到网络，就需要安装以太网卡。以太网卡提供了计算机与网络的接口，支持数据的发送和接收。
>
> **交换机和路由器：** 对于这些网络设备，通常内置了网络接口，无需额外的以太网卡。如果需要扩展网络接口（例如增加更多的网络端口），可以使用模块化交换机或增加外部网络模块，但这些模块与以太网卡不同。

=>交换机是不需要以太网口的，但交换机既然要接受相应的数据帧，那么必定需要实现以太网卡相应的 功能，估计以太网的相应功能已经被集成到芯片的SDK中了吧。所以寄存器设定这种肯定还是有的哈

=>针对于 烽火开发博通交换芯片 最终用的是 动态库的形式 而不是内核加载， 真的是有点难以理解， 某种程度上是不是没法被称为驱动开发啊？头疼，反正以后肯定也不会去找驱动开发的工作吧，而且我已经清楚这一点，随机应变也能应付。

### 14.6 数据接收流程

网络设备接收数据的主要方法是由中断引发设备的中断处理函数，中断处理函数判断中断类型，如果为接收中断，则读取接收到的数据，分配sk_buffer数据结构和数据缓冲区，将接收到的数据复制到数据缓冲区，并调用netif_rx（）函数将sk_buffer传递给上层协议。

```c
static int xxx_poll(struct napi_struct *napi, int budget)
{
 int npackets = 0;
 struct sk_buff *skb;
 struct xxx_priv *priv = container_of(napi, struct xxx_priv, napi);
 struct xxx_packet *pkt;

 while (npackets < budget && priv->rx_queue) {
 /* 从队列中取出数据包 */
 pkt = xxx_dequeue_buf(dev);

 /* 接下来的处理和中断触发的数据包接收一致 */
 skb = dev_alloc_skb(pkt->datalen + 2);
 ...
 skb_reserve(skb, 2);
 memcpy(skb_put(skb, pkt->datalen), pkt->data, pkt->datalen);
 skb->dev = dev;
 skb->protocol = eth_type_trans(skb, dev);
 /* 调用netif_receive_skb，而不是net_rx, 将数据包交给上层协议 */
 netif_receive_skb(skb);

 /* 更改统计数据 */
 priv->stats.rx_packets++;
 priv->stats.rx_bytes += pkt->datalen;
 xxx_release_buffer(pkt);
 npackets++;
 }
 if (npackets < budget) {
 napi_complete(napi);
 xxx_enable_rx_int (…); /* 再次启动网络设备的接收中断 */
 }

```

### 14.7 网络连接状态

### 14.8 参数设置和统计数据

### 14.9 DM9000网卡设备驱动实例

DM9000是开发板采用的网络芯片，是一个高度集成且功耗很低的高速网络控制器，可以和CPU直连，支持10/100MB以太网连接，芯片内部自带4KB双字节的SRAM（3KB用来发送，13KB用来接收）。针对不同的处理器，接口支持8位、16位和32位。DM9000一般直接挂在外面的内存总线上。

## 15 Linux I2C核心、总线与设备驱动 2024.8.28

## 16 USB主机、设备与Gadget驱动

## 17 I2C、SPI、USB驱动架构类比

### 17.1 I2C、SPI、USB驱动架构

对于I2C、SPI这类不具备热插拔能力的总线而言，一般在arch/arm/mach-xxx或者arch/arm/boot/dts中会有相应的板级描述信息，描述外设与主机的连接情况。

对于USB、PCI等总线而言，由于它们具备热插拔能力，所以实际上不存在类似I2C、SPI这样的板级描述信息。换句话说，即便是有这类信息，其实也没有什么用，因为如果写了板子上有个U盘，但实际上没有，其实反而是制造了麻烦；相反，如果没有写，U盘一旦插入，Linux USB子系统会自动探测到一个U盘。

I2C、SPI、USB控制器虽然给别人提供了总线，但是其实自己也是由它自身依附的总线枚举出来的。比如，对于SoC而言，这些控制器一般是直接集成在芯片内部

> 在 Linux 驱动开发中，SPI（Serial Peripheral Interface）是一种广泛使用的串行通信协议，用于在主设备和外设之间进行高速数据传输。SPI 驱动开发涉及与硬件通信的代码实现和配置

> SPI（Serial Peripheral Interface）和 PCI（Peripheral Component Interconnect）是两种不同类型的接口技术，分别用于不同的应用场景。
>
> **SPI（Serial Peripheral Interface）**
>
> - **类型**: 串行通信接口
> - **用途**: 通常用于短距离、低速率的设备间通信，如传感器、EEPROM、ADC/DAC 等外设。
> - **特性**: 简单、点对点通信，主设备和从设备之间的同步数据传输。
>
> **PCI（Peripheral Component Interconnect）**
>
> - **类型**: 并行总线接口
> - **用途**: 用于计算机主板上的高速数据交换，连接主板与各种扩展卡（如显卡、网络卡、存储控制器等）。
> - **特性**: 支持高带宽、设备间并行数据传输，能够处理多设备同时运行。
>
> SPI 主要用于低速的短距离通信，而 PCI 用于高速的数据传输和多设备扩展。

### 17.2 I2C主机和外设眼里的Linux世界

## 18 ARM Linux设备树

## 19 Linux电源管理的系统架构和驱动

## 20 Linux芯片级移植及底层驱动

## 21 Linux设备驱动的调试

### 21.1 GDB调试器的用法

### 21.2 Linux内核调试

printk（）这种方法很原始，但是一般可以解决工程中95%以上的问题。因此具体何时打印，以及打印什么东西，需要工程师逐步建立敏锐的嗅觉。加深对内核的认知，深入理解自己正在调试的模块，这才是快速解决问题的“王道”。工具只是一个辅助手段，无法代替工程师的思维。

### 21.3 内核打印信息—printk

在Linux中，内核打印语句printk（）会将内核信息输出到内核信息缓冲区中

printk（）定义了8个消息级别，分为级别0~7，级别越低（数值越大），消息越不重要，第0级是紧急事件级，第7级是调试级

### 21.4 DEBUG_LL和EARLY_PRINTK

### 21.5 使用“/proc”

在Linux系统中，“/proc”文件系统十分有用，它被内核用于向用户导出信息。“/proc”文件系统是一个虚拟文件系统，通过它可以在Linux内核空间和用户空间之间进行通信。

Linux系统的许多命令本身都是通过分析“/proc”下的文件来完成的，如ps、top、uptime和free等。

### 21.6 Oops

当内核出现类似用户空间的Segmentation Fault时（例如内核访问一个并不存在的虚拟地址），Oops会被打印到控制台和写入内核log缓冲区。

### 21.7 BUG_ON（）和WARN_ON（）

内核中有许多地方调用类似BUG（）的语句，它非常像一个内核运行时的断言，意味着本来不该执行到BUG（）这条语句，一旦执行即抛出Oops

### 21.8 strace

### 21.9 KGDB

### 21.10 使用仿真器调试内核

### 21.11 应用程序调试

### 21.12 Linux性能监控与调优工具

除了保证程序的正确性以外，在项目开发中往往还关心性能和稳定性。这时候，我们往往要对内核、应用程序或整个系统进行性能优化。在性能优化中常用的手段如下。

1. 使用top、vmstat、iostat、sysctl等常用工具
2. 使用高级分析手段，如OProfile、gprof
3. 进行内核跟踪，如LTTng
4. 使用LTP进行压力测试
5. 使用Benchmark评估系统

### 21.13 总结

Linux程序的调试，尤其是内核的调试看起来比较复杂，没有类似于VC++、Tornado的IDE开发环境，最常用的调试手段依然是文本方式的GDB。文本方式的GDB调试器功能异常强大，当我们使用习惯后，就会用得非常自然。



















